// @tiptap/core@3.20.0 downloaded from https://ga.jspm.io/npm:@tiptap/core@3.20.0/dist/index.js

import{liftTarget as t,ReplaceStep as e,ReplaceAroundStep as n,joinPoint as s,Transform as o,canSplit as r,canJoin as i,RemoveMarkStep as a,findWrapping as c}from"@tiptap/pm/transform";import{createParagraphNear as l,deleteSelection as d,exitCode as u,joinUp as p,joinDown as h,joinBackward as m,joinForward as f,joinTextblockBackward as g,joinTextblockForward as v,lift as y,liftEmptyBlock as b,newlineInCode as w,selectNodeBackward as k,selectNodeForward as x,selectParentNode as M,selectTextblockEnd as E,selectTextblockStart as S,setBlockType as C,wrapIn as T}from"@tiptap/pm/commands";import{TextSelection as O,Selection as $,AllSelection as A,NodeSelection as N,Plugin as P,PluginKey as z,EditorState as R}from"@tiptap/pm/state";import{Node as D,Fragment as j,Schema as I,DOMParser as L,DOMSerializer as H,Slice as B}from"@tiptap/pm/model";import{liftListItem as V,sinkListItem as _,wrapInList as U}from"@tiptap/pm/schema-list";import{EditorView as W}from"@tiptap/pm/view";import{keymap as F}from"@tiptap/pm/keymap";var K=Object.defineProperty;var q=(t,e)=>{for(var n in e)K(t,n,{get:e[n],enumerable:true})};function J(t){const{state:e,transaction:n}=t;let{selection:s}=n;let{doc:o}=n;let{storedMarks:r}=n;return{...e,apply:e.apply.bind(e),applyTransaction:e.applyTransaction.bind(e),plugins:e.plugins,schema:e.schema,reconfigure:e.reconfigure.bind(e),toJSON:e.toJSON.bind(e),get storedMarks(){return r},get selection(){return s},get doc(){return o},get tr(){s=n.selection;o=n.doc;r=n.storedMarks;return n}}}var X=class{constructor(t){this.editor=t.editor;this.rawCommands=this.editor.extensionManager.commands;this.customState=t.state}get hasCustomState(){return!!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:t,editor:e,state:n}=this;const{view:s}=e;const{tr:o}=n;const r=this.buildProps(o);return Object.fromEntries(Object.entries(t).map((([t,e])=>{const n=(...t)=>{const n=e(...t)(r);o.getMeta("preventDispatch")||this.hasCustomState||s.dispatch(o);return n};return[t,n]})))}get chain(){return()=>this.createChain()}get can(){return()=>this.createCan()}createChain(t,e=true){const{rawCommands:n,editor:s,state:o}=this;const{view:r}=s;const i=[];const a=!!t;const c=t||o.tr;const l=()=>{a||!e||c.getMeta("preventDispatch")||this.hasCustomState||r.dispatch(c);return i.every((t=>t===true))};const d={...Object.fromEntries(Object.entries(n).map((([t,n])=>{const s=(...t)=>{const s=this.buildProps(c,e);const o=n(...t)(s);i.push(o);return d};return[t,s]}))),run:l};return d}createCan(t){const{rawCommands:e,state:n}=this;const s=false;const o=t||n.tr;const r=this.buildProps(o,s);const i=Object.fromEntries(Object.entries(e).map((([t,e])=>[t,(...t)=>e(...t)({...r,dispatch:void 0})])));return{...i,chain:()=>this.createChain(o,s)}}buildProps(t,e=true){const{rawCommands:n,editor:s,state:o}=this;const{view:r}=s;const i={tr:t,editor:s,view:r,state:J({state:o,transaction:t}),dispatch:e?()=>{}:void 0,chain:()=>this.createChain(t,e),can:()=>this.createCan(t),get commands(){return Object.fromEntries(Object.entries(n).map((([t,e])=>[t,(...t)=>e(...t)(i)])))}};return i}};var Y={};q(Y,{blur:()=>Z,clearContent:()=>Q,clearNodes:()=>G,command:()=>tt,createParagraphNear:()=>et,cut:()=>nt,deleteCurrentNode:()=>st,deleteNode:()=>rt,deleteRange:()=>it,deleteSelection:()=>at,enter:()=>ct,exitCode:()=>lt,extendMarkRange:()=>gt,first:()=>vt,focus:()=>Et,forEach:()=>St,insertContent:()=>Ct,insertContentAt:()=>Pt,joinBackward:()=>Dt,joinDown:()=>Rt,joinForward:()=>jt,joinItemBackward:()=>It,joinItemForward:()=>Lt,joinTextblockBackward:()=>Ht,joinTextblockForward:()=>Bt,joinUp:()=>zt,keyboardShortcut:()=>Ut,lift:()=>Ft,liftEmptyBlock:()=>Kt,liftListItem:()=>qt,newlineInCode:()=>Jt,resetAttributes:()=>Zt,scrollIntoView:()=>Qt,selectAll:()=>Gt,selectNodeBackward:()=>te,selectNodeForward:()=>ee,selectParentNode:()=>ne,selectTextblockEnd:()=>se,selectTextblockStart:()=>oe,setContent:()=>ie,setMark:()=>pn,setMeta:()=>hn,setNode:()=>mn,setNodeSelection:()=>fn,setTextDirection:()=>gn,setTextSelection:()=>vn,sinkListItem:()=>yn,splitBlock:()=>wn,splitListItem:()=>kn,toggleList:()=>En,toggleMark:()=>Sn,toggleNode:()=>Cn,toggleWrap:()=>Tn,undoInputRule:()=>On,unsetAllMarks:()=>$n,unsetMark:()=>An,unsetTextDirection:()=>Nn,updateAttributes:()=>Pn,wrapIn:()=>zn,wrapInList:()=>Rn});var Z=()=>({editor:t,view:e})=>{requestAnimationFrame((()=>{var n;if(!t.isDestroyed){e.dom.blur();(n=window==null?void 0:window.getSelection())==null?void 0:n.removeAllRanges()}}));return true};var Q=(t=true)=>({commands:e})=>e.setContent("",{emitUpdate:t});var G=()=>({state:e,tr:n,dispatch:s})=>{const{selection:o}=n;const{ranges:r}=o;if(!s)return true;r.forEach((({$from:s,$to:o})=>{e.doc.nodesBetween(s.pos,o.pos,((e,s)=>{if(e.type.isText)return;const{doc:o,mapping:r}=n;const i=o.resolve(r.map(s));const a=o.resolve(r.map(s+e.nodeSize));const c=i.blockRange(a);if(!c)return;const l=t(c);if(e.type.isTextblock){const{defaultType:t}=i.parent.contentMatchAt(i.index());n.setNodeMarkup(c.start,t)}(l||l===0)&&n.lift(c,l)}))}));return true};var tt=t=>e=>t(e);var et=()=>({state:t,dispatch:e})=>l(t,e);var nt=(t,e)=>({editor:n,tr:s})=>{const{state:o}=n;const r=o.doc.slice(t.from,t.to);s.deleteRange(t.from,t.to);const i=s.mapping.map(e);s.insert(i,r.content);s.setSelection(new O(s.doc.resolve(Math.max(i-1,0))));return true};var st=()=>({tr:t,dispatch:e})=>{const{selection:n}=t;const s=n.$anchor.node();if(s.content.size>0)return false;const o=t.selection.$anchor;for(let n=o.depth;n>0;n-=1){const r=o.node(n);if(r.type===s.type){if(e){const e=o.before(n);const s=o.after(n);t.delete(e,s).scrollIntoView()}return true}}return false};function ot(t,e){if(typeof t==="string"){if(!e.nodes[t])throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);return e.nodes[t]}return t}var rt=t=>({tr:e,state:n,dispatch:s})=>{const o=ot(t,n.schema);const r=e.selection.$anchor;for(let t=r.depth;t>0;t-=1){const n=r.node(t);if(n.type===o){if(s){const n=r.before(t);const s=r.after(t);e.delete(n,s).scrollIntoView()}return true}}return false};var it=t=>({tr:e,dispatch:n})=>{const{from:s,to:o}=t;n&&e.delete(s,o);return true};var at=()=>({state:t,dispatch:e})=>d(t,e);var ct=()=>({commands:t})=>t.keyboardShortcut("Enter");var lt=()=>({state:t,dispatch:e})=>u(t,e);function dt(t){return Object.prototype.toString.call(t)==="[object RegExp]"}function ut(t,e,n={strict:true}){const s=Object.keys(e);return!s.length||s.every((s=>n.strict?e[s]===t[s]:dt(e[s])?e[s].test(t[s]):e[s]===t[s]))}function pt(t,e,n={}){return t.find((t=>t.type===e&&ut(Object.fromEntries(Object.keys(n).map((e=>[e,t.attrs[e]]))),n)))}function ht(t,e,n={}){return!!pt(t,e,n)}function mt(t,e,n){var s;if(!t||!e)return;let o=t.parent.childAfter(t.parentOffset);o.node&&o.node.marks.some((t=>t.type===e))||(o=t.parent.childBefore(t.parentOffset));if(!o.node||!o.node.marks.some((t=>t.type===e)))return;n=n||((s=o.node.marks[0])==null?void 0:s.attrs);const r=pt([...o.node.marks],e,n);if(!r)return;let i=o.index;let a=t.start()+o.offset;let c=i+1;let l=a+o.node.nodeSize;while(i>0&&ht([...t.parent.child(i-1).marks],e,n)){i-=1;a-=t.parent.child(i).nodeSize}while(c<t.parent.childCount&&ht([...t.parent.child(c).marks],e,n)){l+=t.parent.child(c).nodeSize;c+=1}return{from:a,to:l}}function ft(t,e){if(typeof t==="string"){if(!e.marks[t])throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);return e.marks[t]}return t}var gt=(t,e={})=>({tr:n,state:s,dispatch:o})=>{const r=ft(t,s.schema);const{doc:i,selection:a}=n;const{$from:c,from:l,to:d}=a;if(o){const t=mt(c,r,e);if(t&&t.from<=l&&t.to>=d){const e=O.create(i,t.from,t.to);n.setSelection(e)}}return true};var vt=t=>e=>{const n=typeof t==="function"?t(e):t;for(let t=0;t<n.length;t+=1)if(n[t](e))return true;return false};function yt(t){return t instanceof O}function bt(t=0,e=0,n=0){return Math.min(Math.max(t,e),n)}function wt(t,e=null){if(!e)return null;const n=$.atStart(t);const s=$.atEnd(t);if(e==="start"||e===true)return n;if(e==="end")return s;const o=n.from;const r=s.to;return e==="all"?O.create(t,bt(0,o,r),bt(t.content.size,o,r)):O.create(t,bt(e,o,r),bt(e,o,r))}function kt(){return navigator.platform==="Android"||/android/i.test(navigator.userAgent)}function xt(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}function Mt(){return typeof navigator!=="undefined"&&/^((?!chrome|android).)*safari/i.test(navigator.userAgent)}var Et=(t=null,e={})=>({editor:n,view:s,tr:o,dispatch:r})=>{e={scrollIntoView:true,...e};const i=()=>{(xt()||kt())&&s.dom.focus();!Mt()||xt()||kt()||s.dom.focus({preventScroll:true});requestAnimationFrame((()=>{if(!n.isDestroyed){s.focus();(e==null?void 0:e.scrollIntoView)&&n.commands.scrollIntoView()}}))};try{if(s.hasFocus()&&t===null||t===false)return true}catch{return false}if(r&&t===null&&!yt(n.state.selection)){i();return true}const a=wt(o.doc,t)||n.state.selection;const c=n.state.selection.eq(a);if(r){c||o.setSelection(a);c&&o.storedMarks&&o.setStoredMarks(o.storedMarks);i()}return true};var St=(t,e)=>n=>t.every(((t,s)=>e(t,{...n,index:s})));var Ct=(t,e)=>({tr:n,commands:s})=>s.insertContentAt({from:n.selection.from,to:n.selection.to},t,e);var Tt=t=>{const e=t.childNodes;for(let n=e.length-1;n>=0;n-=1){const s=e[n];s.nodeType===3&&s.nodeValue&&/^(\n\s\s|\n)$/.test(s.nodeValue)?t.removeChild(s):s.nodeType===1&&Tt(s)}return t};function Ot(t){if(typeof window==="undefined")throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");const e=`<body>${t}</body>`;const n=(new window.DOMParser).parseFromString(e,"text/html").body;return Tt(n)}function $t(t,e,n){if(t instanceof D||t instanceof j)return t;n={slice:true,parseOptions:{},...n};const s=typeof t==="object"&&t!==null;const o=typeof t==="string";if(s)try{const s=Array.isArray(t)&&t.length>0;if(s)return j.fromArray(t.map((t=>e.nodeFromJSON(t))));const o=e.nodeFromJSON(t);n.errorOnInvalidContent&&o.check();return o}catch(s){if(n.errorOnInvalidContent)throw new Error("[tiptap error]: Invalid JSON content",{cause:s});console.warn("[tiptap warn]: Invalid content.","Passed value:",t,"Error:",s);return $t("",e,n)}if(o){if(n.errorOnInvalidContent){let s=false;let o="";const r=new I({topNode:e.spec.topNode,marks:e.spec.marks,nodes:e.spec.nodes.append({__tiptap__private__unknown__catch__all__node:{content:"inline*",group:"block",parseDOM:[{tag:"*",getAttrs:t=>{s=true;o=typeof t==="string"?t:t.outerHTML;return null}}]}})});n.slice?L.fromSchema(r).parseSlice(Ot(t),n.parseOptions):L.fromSchema(r).parse(Ot(t),n.parseOptions);if(n.errorOnInvalidContent&&s)throw new Error("[tiptap error]: Invalid HTML content",{cause:new Error(`Invalid element found: ${o}`)})}const s=L.fromSchema(e);return n.slice?s.parseSlice(Ot(t),n.parseOptions).content:s.parse(Ot(t),n.parseOptions)}return $t("",e,n)}function At(t,s,o){const r=t.steps.length-1;if(r<s)return;const i=t.steps[r];if(!(i instanceof e||i instanceof n))return;const a=t.mapping.maps[r];let c=0;a.forEach(((t,e,n,s)=>{c===0&&(c=s)}));t.setSelection($.near(t.doc.resolve(c),o))}var Nt=t=>!("type"in t);var Pt=(t,e,n)=>({tr:s,dispatch:o,editor:r})=>{var i;if(o){n={parseOptions:r.options.parseOptions,updateSelection:true,applyInputRules:false,applyPasteRules:false,...n};let o;const a=t=>{r.emit("contentError",{editor:r,error:t,disableCollaboration:()=>{"collaboration"in r.storage&&typeof r.storage.collaboration==="object"&&r.storage.collaboration&&(r.storage.collaboration.isDisabled=true)}})};const c={preserveWhitespace:"full",...n.parseOptions};if(!n.errorOnInvalidContent&&!r.options.enableContentCheck&&r.options.emitContentError)try{$t(e,r.schema,{parseOptions:c,errorOnInvalidContent:true})}catch(t){a(t)}try{o=$t(e,r.schema,{parseOptions:c,errorOnInvalidContent:(i=n.errorOnInvalidContent)!=null?i:r.options.enableContentCheck})}catch(t){a(t);return false}let{from:l,to:d}=typeof t==="number"?{from:t,to:t}:{from:t.from,to:t.to};let u=true;let p=true;const h=Nt(o)?o:[o];h.forEach((t=>{t.check();u=!!u&&(t.isText&&t.marks.length===0);p=!!p&&t.isBlock}));if(l===d&&p){const{parent:t}=s.doc.resolve(l);const e=t.isTextblock&&!t.type.spec.code&&!t.childCount;if(e){l-=1;d+=1}}let m;if(u){if(Array.isArray(e))m=e.map((t=>t.text||"")).join("");else if(e instanceof j){let t="";e.forEach((e=>{e.text&&(t+=e.text)}));m=t}else m=typeof e==="object"&&e&&e.text?e.text:e;s.insertText(m,l,d)}else{m=o;const t=s.doc.resolve(l);const e=t.node();const n=t.parentOffset===0;const r=e.isText||e.isTextblock;const i=e.content.size>0;n&&r&&i&&(l=Math.max(0,l-1));s.replaceWith(l,d,m)}n.updateSelection&&At(s,s.steps.length-1,-1);n.applyInputRules&&s.setMeta("applyInputRules",{from:l,text:m});n.applyPasteRules&&s.setMeta("applyPasteRules",{from:l,text:m})}return true};var zt=()=>({state:t,dispatch:e})=>p(t,e);var Rt=()=>({state:t,dispatch:e})=>h(t,e);var Dt=()=>({state:t,dispatch:e})=>m(t,e);var jt=()=>({state:t,dispatch:e})=>f(t,e);var It=()=>({state:t,dispatch:e,tr:n})=>{try{const o=s(t.doc,t.selection.$from.pos,-1);if(o===null||o===void 0)return false;n.join(o,2);e&&e(n);return true}catch{return false}};var Lt=()=>({state:t,dispatch:e,tr:n})=>{try{const o=s(t.doc,t.selection.$from.pos,1);if(o===null||o===void 0)return false;n.join(o,2);e&&e(n);return true}catch{return false}};var Ht=()=>({state:t,dispatch:e})=>g(t,e);var Bt=()=>({state:t,dispatch:e})=>v(t,e);function Vt(){return typeof navigator!=="undefined"&&/Mac/.test(navigator.platform)}function _t(t){const e=t.split(/-(?!$)/);let n=e[e.length-1];n==="Space"&&(n=" ");let s;let o;let r;let i;for(let t=0;t<e.length-1;t+=1){const n=e[t];if(/^(cmd|meta|m)$/i.test(n))i=true;else if(/^a(lt)?$/i.test(n))s=true;else if(/^(c|ctrl|control)$/i.test(n))o=true;else if(/^s(hift)?$/i.test(n))r=true;else{if(!/^mod$/i.test(n))throw new Error(`Unrecognized modifier name: ${n}`);xt()||Vt()?i=true:o=true}}s&&(n=`Alt-${n}`);o&&(n=`Ctrl-${n}`);i&&(n=`Meta-${n}`);r&&(n=`Shift-${n}`);return n}var Ut=t=>({editor:e,view:n,tr:s,dispatch:o})=>{const r=_t(t).split(/-(?!$)/);const i=r.find((t=>!["Alt","Ctrl","Meta","Shift"].includes(t)));const a=new KeyboardEvent("keydown",{key:i==="Space"?" ":i,altKey:r.includes("Alt"),ctrlKey:r.includes("Ctrl"),metaKey:r.includes("Meta"),shiftKey:r.includes("Shift"),bubbles:true,cancelable:true});const c=e.captureTransaction((()=>{n.someProp("handleKeyDown",(t=>t(n,a)))}));c==null?void 0:c.steps.forEach((t=>{const e=t.map(s.mapping);e&&o&&s.maybeStep(e)}));return true};function Wt(t,e,n={}){const{from:s,to:o,empty:r}=t.selection;const i=e?ot(e,t.schema):null;const a=[];t.doc.nodesBetween(s,o,((t,e)=>{if(t.isText)return;const n=Math.max(s,e);const r=Math.min(o,e+t.nodeSize);a.push({node:t,from:n,to:r})}));const c=o-s;const l=a.filter((t=>!i||i.name===t.node.type.name)).filter((t=>ut(t.node.attrs,n,{strict:false})));if(r)return!!l.length;const d=l.reduce(((t,e)=>t+e.to-e.from),0);return d>=c}var Ft=(t,e={})=>({state:n,dispatch:s})=>{const o=ot(t,n.schema);const r=Wt(n,o,e);return!!r&&y(n,s)};var Kt=()=>({state:t,dispatch:e})=>b(t,e);var qt=t=>({state:e,dispatch:n})=>{const s=ot(t,e.schema);return V(s)(e,n)};var Jt=()=>({state:t,dispatch:e})=>w(t,e);function Xt(t,e){return e.nodes[t]?"node":e.marks[t]?"mark":null}function Yt(t,e){const n=typeof e==="string"?[e]:e;return Object.keys(t).reduce(((e,s)=>{n.includes(s)||(e[s]=t[s]);return e}),{})}var Zt=(t,e)=>({tr:n,state:s,dispatch:o})=>{let r=null;let i=null;const a=Xt(typeof t==="string"?t:t.name,s.schema);if(!a)return false;a==="node"&&(r=ot(t,s.schema));a==="mark"&&(i=ft(t,s.schema));let c=false;n.selection.ranges.forEach((t=>{s.doc.nodesBetween(t.$from.pos,t.$to.pos,((t,s)=>{if(r&&r===t.type){c=true;o&&n.setNodeMarkup(s,void 0,Yt(t.attrs,e))}i&&t.marks.length&&t.marks.forEach((r=>{if(i===r.type){c=true;o&&n.addMark(s,s+t.nodeSize,i.create(Yt(r.attrs,e)))}}))}))}));return c};var Qt=()=>({tr:t,dispatch:e})=>{e&&t.scrollIntoView();return true};var Gt=()=>({tr:t,dispatch:e})=>{if(e){const e=new A(t.doc);t.setSelection(e)}return true};var te=()=>({state:t,dispatch:e})=>k(t,e);var ee=()=>({state:t,dispatch:e})=>x(t,e);var ne=()=>({state:t,dispatch:e})=>M(t,e);var se=()=>({state:t,dispatch:e})=>E(t,e);var oe=()=>({state:t,dispatch:e})=>S(t,e);function re(t,e,n={},s={}){return $t(t,e,{slice:false,parseOptions:n,errorOnInvalidContent:s.errorOnInvalidContent})}var ie=(t,{errorOnInvalidContent:e,emitUpdate:n=true,parseOptions:s={}}={})=>({editor:o,tr:r,dispatch:i,commands:a})=>{const{doc:c}=r;if(s.preserveWhitespace!=="full"){const a=re(t,o.schema,s,{errorOnInvalidContent:e!=null?e:o.options.enableContentCheck});i&&r.replaceWith(0,c.content.size,a).setMeta("preventUpdate",!n);return true}i&&r.setMeta("preventUpdate",!n);return a.insertContentAt({from:0,to:c.content.size},t,{parseOptions:s,errorOnInvalidContent:e!=null?e:o.options.enableContentCheck})};function ae(t,e){const n=ft(e,t.schema);const{from:s,to:o,empty:r}=t.selection;const i=[];if(r){t.storedMarks&&i.push(...t.storedMarks);i.push(...t.selection.$head.marks())}else t.doc.nodesBetween(s,o,(t=>{i.push(...t.marks)}));const a=i.find((t=>t.type.name===n.name));return a?{...a.attrs}:{}}function ce(t,e){const n=new o(t);e.forEach((t=>{t.steps.forEach((t=>{n.step(t)}))}));return n}function le(t){for(let e=0;e<t.edgeCount;e+=1){const{type:n}=t.edge(e);if(n.isTextblock&&!n.hasRequiredAttrs())return n}return null}function de(t,e){const n=[];t.descendants(((t,s)=>{e(t)&&n.push({node:t,pos:s})}));return n}function ue(t,e,n){const s=[];t.nodesBetween(e.from,e.to,((t,e)=>{n(t)&&s.push({node:t,pos:e})}));return s}function pe(t,e){for(let n=t.depth;n>0;n-=1){const s=t.node(n);if(e(s))return{pos:n>0?t.before(n):0,start:t.start(n),depth:n,node:s}}}function he(t){return e=>pe(e.$from,t)}function me(t,e,n){if(t.config[e]===void 0&&t.parent)return me(t.parent,e,n);if(typeof t.config[e]==="function"){const s=t.config[e].bind({...n,parent:t.parent?me(t.parent,e,n):null});return s}return t.config[e]}function fe(t){return t.map((t=>{const e={name:t.name,options:t.options,storage:t.storage};const n=me(t,"addExtensions",e);return n?[t,...fe(n())]:t})).flat(10)}function ge(t,e){const n=H.fromSchema(e).serializeFragment(t);const s=document.implementation.createHTMLDocument();const o=s.createElement("div");o.appendChild(n);return o.innerHTML}function ve(t){return typeof t==="function"}function ye(t,e=void 0,...n){return ve(t)?e?t.bind(e)(...n):t(...n):t}function be(t={}){return Object.keys(t).length===0&&t.constructor===Object}function we(t){const e=t.filter((t=>t.type==="extension"));const n=t.filter((t=>t.type==="node"));const s=t.filter((t=>t.type==="mark"));return{baseExtensions:e,nodeExtensions:n,markExtensions:s}}function ke(t){const e=[];const{nodeExtensions:n,markExtensions:s}=we(t);const o=[...n,...s];const r={default:null,validate:void 0,rendered:true,renderHTML:null,parseHTML:null,keepOnSplit:true,isRequired:false};const i=n.filter((t=>t.name!=="text")).map((t=>t.name));const a=s.map((t=>t.name));const c=[...i,...a];t.forEach((t=>{const n={name:t.name,options:t.options,storage:t.storage,extensions:o};const s=me(t,"addGlobalAttributes",n);if(!s)return;const l=s();l.forEach((t=>{let n;n=Array.isArray(t.types)?t.types:t.types==="*"?c:t.types==="nodes"?i:t.types==="marks"?a:[];n.forEach((n=>{Object.entries(t.attributes).forEach((([t,s])=>{e.push({type:n,name:t,attribute:{...r,...s}})}))}))}))}));o.forEach((t=>{const n={name:t.name,options:t.options,storage:t.storage};const s=me(t,"addAttributes",n);if(!s)return;const o=s();Object.entries(o).forEach((([n,s])=>{const o={...r,...s};typeof(o==null?void 0:o.default)==="function"&&(o.default=o.default());(o==null?void 0:o.isRequired)&&(o==null?void 0:o.default)===void 0&&delete o.default;e.push({type:t.name,name:n,attribute:o})}))}));return e}function xe(...t){return t.filter((t=>!!t)).reduce(((t,e)=>{const n={...t};Object.entries(e).forEach((([t,e])=>{const s=n[t];if(s)if(t==="class"){const s=e?String(e).split(" "):[];const o=n[t]?n[t].split(" "):[];const r=s.filter((t=>!o.includes(t)));n[t]=[...o,...r].join(" ")}else if(t==="style"){const s=e?e.split(";").map((t=>t.trim())).filter(Boolean):[];const o=n[t]?n[t].split(";").map((t=>t.trim())).filter(Boolean):[];const r=new Map;o.forEach((t=>{const[e,n]=t.split(":").map((t=>t.trim()));r.set(e,n)}));s.forEach((t=>{const[e,n]=t.split(":").map((t=>t.trim()));r.set(e,n)}));n[t]=Array.from(r.entries()).map((([t,e])=>`${t}: ${e}`)).join("; ")}else n[t]=e;else n[t]=e}));return n}),{})}function Me(t,e){return e.filter((e=>e.type===t.type.name)).filter((t=>t.attribute.rendered)).map((e=>e.attribute.renderHTML?e.attribute.renderHTML(t.attrs)||{}:{[e.name]:t.attrs[e.name]})).reduce(((t,e)=>xe(t,e)),{})}function Ee(t){return typeof t!=="string"?t:t.match(/^[+-]?(?:\d*\.)?\d+$/)?Number(t):t==="true"||t!=="false"&&t}function Se(t,e){return"style"in t?t:{...t,getAttrs:n=>{const s=t.getAttrs?t.getAttrs(n):t.attrs;if(s===false)return false;const o=e.reduce(((t,e)=>{const s=e.attribute.parseHTML?e.attribute.parseHTML(n):Ee(n.getAttribute(e.name));return s===null||s===void 0?t:{...t,[e.name]:s}}),{});return{...s,...o}}}}function Ce(t){return Object.fromEntries(Object.entries(t).filter((([t,e])=>(t!=="attrs"||!be(e))&&(e!==null&&e!==void 0))))}function Te(t){var e,n;const s={};!((e=t==null?void 0:t.attribute)==null?void 0:e.isRequired)&&"default"in((t==null?void 0:t.attribute)||{})&&(s.default=t.attribute.default);((n=t==null?void 0:t.attribute)==null?void 0:n.validate)!==void 0&&(s.validate=t.attribute.validate);return[t.name,s]}function Oe(t,e){var n;const s=ke(t);const{nodeExtensions:o,markExtensions:r}=we(t);const i=(n=o.find((t=>me(t,"topNode"))))==null?void 0:n.name;const a=Object.fromEntries(o.map((n=>{const o=s.filter((t=>t.type===n.name));const r={name:n.name,options:n.options,storage:n.storage,editor:e};const i=t.reduce(((t,e)=>{const s=me(e,"extendNodeSchema",r);return{...t,...s?s(n):{}}}),{});const a=Ce({...i,content:ye(me(n,"content",r)),marks:ye(me(n,"marks",r)),group:ye(me(n,"group",r)),inline:ye(me(n,"inline",r)),atom:ye(me(n,"atom",r)),selectable:ye(me(n,"selectable",r)),draggable:ye(me(n,"draggable",r)),code:ye(me(n,"code",r)),whitespace:ye(me(n,"whitespace",r)),linebreakReplacement:ye(me(n,"linebreakReplacement",r)),defining:ye(me(n,"defining",r)),isolating:ye(me(n,"isolating",r)),attrs:Object.fromEntries(o.map(Te))});const c=ye(me(n,"parseHTML",r));c&&(a.parseDOM=c.map((t=>Se(t,o))));const l=me(n,"renderHTML",r);l&&(a.toDOM=t=>l({node:t,HTMLAttributes:Me(t,o)}));const d=me(n,"renderText",r);d&&(a.toText=d);return[n.name,a]})));const c=Object.fromEntries(r.map((n=>{const o=s.filter((t=>t.type===n.name));const r={name:n.name,options:n.options,storage:n.storage,editor:e};const i=t.reduce(((t,e)=>{const s=me(e,"extendMarkSchema",r);return{...t,...s?s(n):{}}}),{});const a=Ce({...i,inclusive:ye(me(n,"inclusive",r)),excludes:ye(me(n,"excludes",r)),group:ye(me(n,"group",r)),spanning:ye(me(n,"spanning",r)),code:ye(me(n,"code",r)),attrs:Object.fromEntries(o.map(Te))});const c=ye(me(n,"parseHTML",r));c&&(a.parseDOM=c.map((t=>Se(t,o))));const l=me(n,"renderHTML",r);l&&(a.toDOM=t=>l({mark:t,HTMLAttributes:Me(t,o)}));return[n.name,a]})));return new I({topNode:i,nodes:a,marks:c})}function $e(t){const e=t.filter(((e,n)=>t.indexOf(e)!==n));return Array.from(new Set(e))}function Ae(t){const e=100;return t.sort(((t,n)=>{const s=me(t,"priority")||e;const o=me(n,"priority")||e;return s>o?-1:s<o?1:0}))}function Ne(t){const e=Ae(fe(t));const n=$e(e.map((t=>t.name)));n.length&&console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map((t=>`'${t}'`)).join(", ")}]. This can lead to issues.`);return e}function Pe(t,e){const n=Ne(t);return Oe(n,e)}function ze(t,e){const n=Pe(e);const s=D.fromJSON(n,t);return ge(s.content,n)}function Re(t,e){const n=Pe(e);const s=Ot(t);return L.fromSchema(n).parse(s).toJSON()}function De(t,e,n){const{from:s,to:o}=e;const{blockSeparator:r="\n\n",textSerializers:i={}}=n||{};let a="";t.nodesBetween(s,o,((t,n,c,l)=>{var d;t.isBlock&&n>s&&(a+=r);const u=i==null?void 0:i[t.type.name];if(u){c&&(a+=u({node:t,pos:n,parent:c,index:l,range:e}));return false}t.isText&&(a+=(d=t==null?void 0:t.text)==null?void 0:d.slice(Math.max(s,n)-n,o-n))}));return a}function je(t,e){const n={from:0,to:t.content.size};return De(t,n,e)}function Ie(t){return Object.fromEntries(Object.entries(t.nodes).filter((([,t])=>t.spec.toText)).map((([t,e])=>[t,e.spec.toText])))}function Le(t,e,n){const{blockSeparator:s="\n\n",textSerializers:o={}}=n||{};const r=Pe(e);const i=D.fromJSON(r,t);return je(i,{blockSeparator:s,textSerializers:{...Ie(r),...o}})}function He(t,e){const n=ot(e,t.schema);const{from:s,to:o}=t.selection;const r=[];t.doc.nodesBetween(s,o,(t=>{r.push(t)}));const i=r.reverse().find((t=>t.type.name===n.name));return i?{...i.attrs}:{}}function Be(t,e){const n=Xt(typeof e==="string"?e:e.name,t.schema);return n==="node"?He(t,e):n==="mark"?ae(t,e):{}}function Ve(t,e=JSON.stringify){const n={};return t.filter((t=>{const s=e(t);return!Object.prototype.hasOwnProperty.call(n,s)&&(n[s]=true)}))}function _e(t){const e=Ve(t);return e.length===1?e:e.filter(((t,n)=>{const s=e.filter(((t,e)=>e!==n));return!s.some((e=>t.oldRange.from>=e.oldRange.from&&t.oldRange.to<=e.oldRange.to&&t.newRange.from>=e.newRange.from&&t.newRange.to<=e.newRange.to))}))}function Ue(t){const{mapping:e,steps:n}=t;const s=[];e.maps.forEach(((t,o)=>{const r=[];if(t.ranges.length)t.forEach(((t,e)=>{r.push({from:t,to:e})}));else{const{from:t,to:e}=n[o];if(t===void 0||e===void 0)return;r.push({from:t,to:e})}r.forEach((({from:t,to:n})=>{const r=e.slice(o).map(t,-1);const i=e.slice(o).map(n);const a=e.invert().map(r,-1);const c=e.invert().map(i);s.push({oldRange:{from:a,to:c},newRange:{from:r,to:i}})}))}));return _e(s)}function We(t,e=0){const n=t.type===t.type.schema.topNodeType;const s=n?0:1;const o=e;const r=o+t.nodeSize;const i=t.marks.map((t=>{const e={type:t.type.name};Object.keys(t.attrs).length&&(e.attrs={...t.attrs});return e}));const a={...t.attrs};const c={type:t.type.name,from:o,to:r};Object.keys(a).length&&(c.attrs=a);i.length&&(c.marks=i);if(t.content.childCount){c.content=[];t.forEach(((t,n)=>{var o;(o=c.content)==null?void 0:o.push(We(t,e+n+s))}))}t.text&&(c.text=t.text);return c}function Fe(t,e,n){const s=[];t===e?n.resolve(t).marks().forEach((e=>{const o=n.resolve(t);const r=mt(o,e.type);r&&s.push({mark:e,...r})})):n.nodesBetween(t,e,((t,e)=>{t&&(t==null?void 0:t.nodeSize)!==void 0&&s.push(...t.marks.map((n=>({from:e,to:e+t.nodeSize,mark:n}))))}));return s}var Ke=(t,e,n,s=20)=>{const o=t.doc.resolve(n);let r=s;let i=null;while(r>0&&i===null){const t=o.node(r);(t==null?void 0:t.type.name)===e?i=t:r-=1}return[i,r]};function qe(t,e){return e.nodes[t]||e.marks[t]||null}function Je(t,e,n){return Object.fromEntries(Object.entries(n).filter((([n])=>{const s=t.find((t=>t.type===e&&t.name===n));return!!s&&s.attribute.keepOnSplit})))}var Xe=(t,e=500)=>{let n="";const s=t.parentOffset;t.parent.nodesBetween(Math.max(0,s-e),s,((t,e,o,r)=>{var i,a;const c=((a=(i=t.type.spec).toText)==null?void 0:a.call(i,{node:t,pos:e,parent:o,index:r}))||t.textContent||"%leaf%";n+=t.isAtom&&!t.isText?c:c.slice(0,Math.max(0,s-e))}));return n};function Ye(t,e,n={}){const{empty:s,ranges:o}=t.selection;const r=e?ft(e,t.schema):null;if(s)return!!(t.storedMarks||t.selection.$from.marks()).filter((t=>!r||r.name===t.type.name)).find((t=>ut(t.attrs,n,{strict:false})));let i=0;const a=[];o.forEach((({$from:e,$to:n})=>{const s=e.pos;const o=n.pos;t.doc.nodesBetween(s,o,((t,e)=>{if(r&&t.inlineContent&&!t.type.allowsMarkType(r))return false;if(!t.isText&&!t.marks.length)return;const n=Math.max(s,e);const c=Math.min(o,e+t.nodeSize);const l=c-n;i+=l;a.push(...t.marks.map((t=>({mark:t,from:n,to:c}))))}))}));if(i===0)return false;const c=a.filter((t=>!r||r.name===t.mark.type.name)).filter((t=>ut(t.mark.attrs,n,{strict:false}))).reduce(((t,e)=>t+e.to-e.from),0);const l=a.filter((t=>!r||t.mark.type!==r&&t.mark.type.excludes(r))).reduce(((t,e)=>t+e.to-e.from),0);const d=c>0?c+l:c;return d>=i}function Ze(t,e,n={}){if(!e)return Wt(t,null,n)||Ye(t,null,n);const s=Xt(e,t.schema);return s==="node"?Wt(t,e,n):s==="mark"&&Ye(t,e,n)}var Qe=(t,e)=>{const{$from:n,$to:s,$anchor:o}=t.selection;if(e){const n=he((t=>t.type.name===e))(t.selection);if(!n)return false;const s=t.doc.resolve(n.pos+1);return o.pos+1===s.end()}return!(s.parentOffset<s.parent.nodeSize-2||n.pos!==s.pos)};var Ge=t=>{const{$from:e,$to:n}=t.selection;return!(e.parentOffset>0||e.pos!==n.pos)};function tn(t,e){return Array.isArray(e)?e.some((e=>{const n=typeof e==="string"?e:e.name;return n===t.name})):e}function en(t,e){const{nodeExtensions:n}=we(e);const s=n.find((e=>e.name===t));if(!s)return false;const o={name:s.name,options:s.options,storage:s.storage};const r=ye(me(s,"group",o));return typeof r==="string"&&r.split(" ").includes("list")}function nn(t,{checkChildren:e=true,ignoreWhitespace:n=false}={}){var s;if(n){if(t.type.name==="hardBreak")return true;if(t.isText)return/^\s*$/m.test((s=t.text)!=null?s:"")}if(t.isText)return!t.text;if(t.isAtom||t.isLeaf)return false;if(t.content.childCount===0)return true;if(e){let s=true;t.content.forEach((t=>{s!==false&&(nn(t,{ignoreWhitespace:n,checkChildren:e})||(s=false))}));return s}return false}function sn(t){return t instanceof N}var on=class _MappablePosition{constructor(t){this.position=t}static fromJSON(t){return new _MappablePosition(t.position)}toJSON(){return{position:this.position}}};function rn(t,e){const n=e.mapping.mapResult(t.position);return{position:new on(n.pos),mapResult:n}}function an(t){return new on(t)}function cn(t,e,n){const s=0;const o=t.state.doc.content.size;const r=bt(e,s,o);const i=bt(n,s,o);const a=t.coordsAtPos(r);const c=t.coordsAtPos(i,-1);const l=Math.min(a.top,c.top);const d=Math.max(a.bottom,c.bottom);const u=Math.min(a.left,c.left);const p=Math.max(a.right,c.right);const h=p-u;const m=d-l;const f=u;const g=l;const v={top:l,bottom:d,left:u,right:p,width:h,height:m,x:f,y:g};return{...v,toJSON:()=>v}}function ln({json:t,validMarks:e,validNodes:n,options:s,rewrittenContent:o=[]}){t.marks&&Array.isArray(t.marks)&&(t.marks=t.marks.filter((t=>{const n=typeof t==="string"?t:t.type;if(e.has(n))return true;o.push({original:JSON.parse(JSON.stringify(t)),unsupported:n});return false})));t.content&&Array.isArray(t.content)&&(t.content=t.content.map((t=>ln({json:t,validMarks:e,validNodes:n,options:s,rewrittenContent:o}).json)).filter((t=>t!==null&&t!==void 0)));if(t.type&&!n.has(t.type)){o.push({original:JSON.parse(JSON.stringify(t)),unsupported:t.type});if(t.content&&Array.isArray(t.content)&&(s==null?void 0:s.fallbackToParagraph)!==false){t.type="paragraph";return{json:t,rewrittenContent:o}}return{json:null,rewrittenContent:o}}return{json:t,rewrittenContent:o}}function dn(t,e,n){return ln({json:t,validNodes:new Set(Object.keys(e.nodes)),validMarks:new Set(Object.keys(e.marks)),options:n})}function un(t,e,n){var s;const{selection:o}=e;let r=null;yt(o)&&(r=o.$cursor);if(r){const e=(s=t.storedMarks)!=null?s:r.marks();const o=r.parent.type.allowsMarkType(n);return o&&(!!n.isInSet(e)||!e.some((t=>t.type.excludes(n))))}const{ranges:i}=o;return i.some((({$from:e,$to:s})=>{let o=e.depth===0&&(t.doc.inlineContent&&t.doc.type.allowsMarkType(n));t.doc.nodesBetween(e.pos,s.pos,((t,e,s)=>{if(o)return false;if(t.isInline){const e=!s||s.type.allowsMarkType(n);const r=!!n.isInSet(t.marks)||!t.marks.some((t=>t.type.excludes(n)));o=e&&r}return!o}));return o}))}var pn=(t,e={})=>({tr:n,state:s,dispatch:o})=>{const{selection:r}=n;const{empty:i,ranges:a}=r;const c=ft(t,s.schema);if(o)if(i){const t=ae(s,c);n.addStoredMark(c.create({...t,...e}))}else a.forEach((t=>{const o=t.$from.pos;const r=t.$to.pos;s.doc.nodesBetween(o,r,((t,s)=>{const i=Math.max(s,o);const a=Math.min(s+t.nodeSize,r);const l=t.marks.find((t=>t.type===c));l?t.marks.forEach((t=>{c===t.type&&n.addMark(i,a,c.create({...t.attrs,...e}))})):n.addMark(i,a,c.create(e))}))}));return un(s,n,c)};var hn=(t,e)=>({tr:n})=>{n.setMeta(t,e);return true};var mn=(t,e={})=>({state:n,dispatch:s,chain:o})=>{const r=ot(t,n.schema);let i;n.selection.$anchor.sameParent(n.selection.$head)&&(i=n.selection.$anchor.parent.attrs);if(!r.isTextblock){console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');return false}return o().command((({commands:t})=>{const s=C(r,{...i,...e})(n);return!!s||t.clearNodes()})).command((({state:t})=>C(r,{...i,...e})(t,s))).run()};var fn=t=>({tr:e,dispatch:n})=>{if(n){const{doc:n}=e;const s=bt(t,0,n.content.size);const o=N.create(n,s);e.setSelection(o)}return true};var gn=(t,e)=>({tr:n,state:s,dispatch:o})=>{const{selection:r}=s;let i;let a;if(typeof e==="number"){i=e;a=e}else if(e&&"from"in e&&"to"in e){i=e.from;a=e.to}else{i=r.from;a=r.to}o&&n.doc.nodesBetween(i,a,((e,s)=>{e.isText||n.setNodeMarkup(s,void 0,{...e.attrs,dir:t})}));return true};var vn=t=>({tr:e,dispatch:n})=>{if(n){const{doc:n}=e;const{from:s,to:o}=typeof t==="number"?{from:t,to:t}:t;const r=O.atStart(n).from;const i=O.atEnd(n).to;const a=bt(s,r,i);const c=bt(o,r,i);const l=O.create(n,a,c);e.setSelection(l)}return true};var yn=t=>({state:e,dispatch:n})=>{const s=ot(t,e.schema);return _(s)(e,n)};function bn(t,e){const n=t.storedMarks||t.selection.$to.parentOffset&&t.selection.$from.marks();if(n){const s=n.filter((t=>e==null?void 0:e.includes(t.type.name)));t.tr.ensureMarks(s)}}var wn=({keepMarks:t=true}={})=>({tr:e,state:n,dispatch:s,editor:o})=>{const{selection:i,doc:a}=e;const{$from:c,$to:l}=i;const d=o.extensionManager.attributes;const u=Je(d,c.node().type.name,c.node().attrs);if(i instanceof N&&i.node.isBlock){if(!c.parentOffset||!r(a,c.pos))return false;if(s){t&&bn(n,o.extensionManager.splittableMarks);e.split(c.pos).scrollIntoView()}return true}if(!c.parent.isBlock)return false;const p=l.parentOffset===l.parent.content.size;const h=c.depth===0?void 0:le(c.node(-1).contentMatchAt(c.indexAfter(-1)));let m=p&&h?[{type:h,attrs:u}]:void 0;let f=r(e.doc,e.mapping.map(c.pos),1,m);if(!m&&!f&&r(e.doc,e.mapping.map(c.pos),1,h?[{type:h}]:void 0)){f=true;m=h?[{type:h,attrs:u}]:void 0}if(s){if(f){i instanceof O&&e.deleteSelection();e.split(e.mapping.map(c.pos),1,m);if(h&&!p&&!c.parentOffset&&c.parent.type!==h){const t=e.mapping.map(c.before());const n=e.doc.resolve(t);c.node(-1).canReplaceWith(n.index(),n.index()+1,h)&&e.setNodeMarkup(e.mapping.map(c.before()),h)}}t&&bn(n,o.extensionManager.splittableMarks);e.scrollIntoView()}return f};var kn=(t,e={})=>({tr:n,state:s,dispatch:o,editor:i})=>{var a;const c=ot(t,s.schema);const{$from:l,$to:d}=s.selection;const u=s.selection.node;if(u&&u.isBlock||l.depth<2||!l.sameParent(d))return false;const p=l.node(-1);if(p.type!==c)return false;const h=i.extensionManager.attributes;if(l.parent.content.size===0&&l.node(-1).childCount===l.indexAfter(-1)){if(l.depth===2||l.node(-3).type!==c||l.index(-2)!==l.node(-2).childCount-1)return false;if(o){let t=j.empty;const s=l.index(-1)?1:l.index(-2)?2:3;for(let e=l.depth-s;e>=l.depth-3;e-=1)t=j.from(l.node(e).copy(t));const o=l.indexAfter(-1)<l.node(-2).childCount?1:l.indexAfter(-2)<l.node(-3).childCount?2:3;const r={...Je(h,l.node().type.name,l.node().attrs),...e};const i=((a=c.contentMatch.defaultType)==null?void 0:a.createAndFill(r))||void 0;t=t.append(j.from(c.createAndFill(null,i)||void 0));const d=l.before(l.depth-(s-1));n.replace(d,l.after(-o),new B(t,4-s,0));let u=-1;n.doc.nodesBetween(d,n.doc.content.size,((t,e)=>{if(u>-1)return false;t.isTextblock&&t.content.size===0&&(u=e+1)}));u>-1&&n.setSelection(O.near(n.doc.resolve(u)));n.scrollIntoView()}return true}const m=d.pos===l.end()?p.contentMatchAt(0).defaultType:null;const f={...Je(h,p.type.name,p.attrs),...e};const g={...Je(h,l.node().type.name,l.node().attrs),...e};n.delete(l.pos,d.pos);const v=m?[{type:c,attrs:f},{type:m,attrs:g}]:[{type:c,attrs:f}];if(!r(n.doc,l.pos,2))return false;if(o){const{selection:t,storedMarks:e}=s;const{splittableMarks:r}=i.extensionManager;const a=e||t.$to.parentOffset&&t.$from.marks();n.split(l.pos,2,v).scrollIntoView();if(!a||!o)return true;const c=a.filter((t=>r.includes(t.type.name)));n.ensureMarks(c)}return true};var xn=(t,e)=>{const n=he((t=>t.type===e))(t.selection);if(!n)return true;const s=t.doc.resolve(Math.max(0,n.pos-1)).before(n.depth);if(s===void 0)return true;const o=t.doc.nodeAt(s);const r=n.node.type===(o==null?void 0:o.type)&&i(t.doc,n.pos);if(!r)return true;t.join(n.pos);return true};var Mn=(t,e)=>{const n=he((t=>t.type===e))(t.selection);if(!n)return true;const s=t.doc.resolve(n.start).after(n.depth);if(s===void 0)return true;const o=t.doc.nodeAt(s);const r=n.node.type===(o==null?void 0:o.type)&&i(t.doc,s);if(!r)return true;t.join(s);return true};var En=(t,e,n,s={})=>({editor:o,tr:r,state:i,dispatch:a,chain:c,commands:l,can:d})=>{const{extensions:u,splittableMarks:p}=o.extensionManager;const h=ot(t,i.schema);const m=ot(e,i.schema);const{selection:f,storedMarks:g}=i;const{$from:v,$to:y}=f;const b=v.blockRange(y);const w=g||f.$to.parentOffset&&f.$from.marks();if(!b)return false;const k=he((t=>en(t.type.name,u)))(f);if(b.depth>=1&&k&&b.depth-k.depth<=1){if(k.node.type===h)return l.liftListItem(m);if(en(k.node.type.name,u)&&h.validContent(k.node.content)&&a)return c().command((()=>{r.setNodeMarkup(k.pos,h);return true})).command((()=>xn(r,h))).command((()=>Mn(r,h))).run()}return n&&w&&a?c().command((()=>{const t=d().wrapInList(h,s);const e=w.filter((t=>p.includes(t.type.name)));r.ensureMarks(e);return!!t||l.clearNodes()})).wrapInList(h,s).command((()=>xn(r,h))).command((()=>Mn(r,h))).run():c().command((()=>{const t=d().wrapInList(h,s);return!!t||l.clearNodes()})).wrapInList(h,s).command((()=>xn(r,h))).command((()=>Mn(r,h))).run()};var Sn=(t,e={},n={})=>({state:s,commands:o})=>{const{extendEmptyMarkRange:r=false}=n;const i=ft(t,s.schema);const a=Ye(s,i,e);return a?o.unsetMark(i,{extendEmptyMarkRange:r}):o.setMark(i,e)};var Cn=(t,e,n={})=>({state:s,commands:o})=>{const r=ot(t,s.schema);const i=ot(e,s.schema);const a=Wt(s,r,n);let c;s.selection.$anchor.sameParent(s.selection.$head)&&(c=s.selection.$anchor.parent.attrs);return a?o.setNode(i,c):o.setNode(r,{...c,...n})};var Tn=(t,e={})=>({state:n,commands:s})=>{const o=ot(t,n.schema);const r=Wt(n,o,e);return r?s.lift(o):s.wrapIn(o,e)};var On=()=>({state:t,dispatch:e})=>{const n=t.plugins;for(let s=0;s<n.length;s+=1){const o=n[s];let r;if(o.spec.isInputRules&&(r=o.getState(t))){if(e){const e=t.tr;const n=r.transform;for(let t=n.steps.length-1;t>=0;t-=1)e.step(n.steps[t].invert(n.docs[t]));if(r.text){const n=e.doc.resolve(r.from).marks();e.replaceWith(r.from,r.to,t.schema.text(r.text,n))}else e.delete(r.from,r.to)}return true}}return false};var $n=()=>({tr:t,dispatch:e})=>{const{selection:n}=t;const{empty:s,ranges:o}=n;if(s)return true;e&&o.forEach((e=>{t.removeMark(e.$from.pos,e.$to.pos)}));return true};var An=(t,e={})=>({tr:n,state:s,dispatch:o})=>{var r;const{extendEmptyMarkRange:i=false}=e;const{selection:a}=n;const c=ft(t,s.schema);const{$from:l,empty:d,ranges:u}=a;if(!o)return true;if(d&&i){let{from:t,to:e}=a;const s=(r=l.marks().find((t=>t.type===c)))==null?void 0:r.attrs;const o=mt(l,c,s);if(o){t=o.from;e=o.to}n.removeMark(t,e,c)}else u.forEach((t=>{n.removeMark(t.$from.pos,t.$to.pos,c)}));n.removeStoredMark(c);return true};var Nn=t=>({tr:e,state:n,dispatch:s})=>{const{selection:o}=n;let r;let i;if(typeof t==="number"){r=t;i=t}else if(t&&"from"in t&&"to"in t){r=t.from;i=t.to}else{r=o.from;i=o.to}s&&e.doc.nodesBetween(r,i,((t,n)=>{if(t.isText)return;const s={...t.attrs};delete s.dir;e.setNodeMarkup(n,void 0,s)}));return true};var Pn=(t,e={})=>({tr:n,state:s,dispatch:o})=>{let r=null;let i=null;const a=Xt(typeof t==="string"?t:t.name,s.schema);if(!a)return false;a==="node"&&(r=ot(t,s.schema));a==="mark"&&(i=ft(t,s.schema));let c=false;n.selection.ranges.forEach((t=>{const a=t.$from.pos;const l=t.$to.pos;let d;let u;let p;let h;n.selection.empty?s.doc.nodesBetween(a,l,((t,e)=>{if(r&&r===t.type){c=true;p=Math.max(e,a);h=Math.min(e+t.nodeSize,l);d=e;u=t}})):s.doc.nodesBetween(a,l,((t,s)=>{if(s<a&&r&&r===t.type){c=true;p=Math.max(s,a);h=Math.min(s+t.nodeSize,l);d=s;u=t}if(s>=a&&s<=l){if(r&&r===t.type){c=true;o&&n.setNodeMarkup(s,void 0,{...t.attrs,...e})}i&&t.marks.length&&t.marks.forEach((r=>{if(i===r.type){c=true;if(o){const o=Math.max(s,a);const c=Math.min(s+t.nodeSize,l);n.addMark(o,c,i.create({...r.attrs,...e}))}}}))}}));if(u){d!==void 0&&o&&n.setNodeMarkup(d,void 0,{...u.attrs,...e});i&&u.marks.length&&u.marks.forEach((t=>{i===t.type&&o&&n.addMark(p,h,i.create({...t.attrs,...e}))}))}}));return c};var zn=(t,e={})=>({state:n,dispatch:s})=>{const o=ot(t,n.schema);return T(o,e)(n,s)};var Rn=(t,e={})=>({state:n,dispatch:s})=>{const o=ot(t,n.schema);return U(o,e)(n,s)};var Dn=class{constructor(){this.callbacks={}}on(t,e){this.callbacks[t]||(this.callbacks[t]=[]);this.callbacks[t].push(e);return this}emit(t,...e){const n=this.callbacks[t];n&&n.forEach((t=>t.apply(this,e)));return this}off(t,e){const n=this.callbacks[t];n&&(e?this.callbacks[t]=n.filter((t=>t!==e)):delete this.callbacks[t]);return this}once(t,e){const n=(...s)=>{this.off(t,n);e.apply(this,s)};return this.on(t,n)}removeAllListeners(){this.callbacks={}}};var jn=class{constructor(t){var e;this.find=t.find;this.handler=t.handler;this.undoable=(e=t.undoable)==null||e}};var In=(t,e)=>{if(dt(e))return e.exec(t);const n=e(t);if(!n)return null;const s=[n.text];s.index=n.index;s.input=t;s.data=n.data;if(n.replaceWith){n.text.includes(n.replaceWith)||console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');s.push(n.replaceWith)}return s};function Ln(t){var e;const{editor:n,from:s,to:o,text:r,rules:i,plugin:a}=t;const{view:c}=n;if(c.composing)return false;const l=c.state.doc.resolve(s);if(l.parent.type.spec.code||!!((e=l.nodeBefore||l.nodeAfter)==null?void 0:e.marks.find((t=>t.type.spec.code))))return false;let d=false;const u=Xe(l)+r;i.forEach((t=>{if(d)return;const e=In(u,t.find);if(!e)return;const i=c.state.tr;const l=J({state:c.state,transaction:i});const p={from:s-(e[0].length-r.length),to:o};const{commands:h,chain:m,can:f}=new X({editor:n,state:l});const g=t.handler({state:l,range:p,match:e,commands:h,chain:m,can:f});if(g!==null&&i.steps.length){t.undoable&&i.setMeta(a,{transform:i,from:s,to:o,text:r});c.dispatch(i);d=true}}));return d}function Hn(t){const{editor:e,rules:n}=t;const s=new P({state:{init(){return null},apply(t,o,r){const i=t.getMeta(s);if(i)return i;const a=t.getMeta("applyInputRules");const c=!!a;c&&setTimeout((()=>{let{text:t}=a;typeof t==="string"?t:t=ge(j.from(t),r.schema);const{from:o}=a;const i=o+t.length;Ln({editor:e,from:o,to:i,text:t,rules:n,plugin:s})}));return t.selectionSet||t.docChanged?null:o}},props:{handleTextInput(t,o,r,i){return Ln({editor:e,from:o,to:r,text:i,rules:n,plugin:s})},handleDOMEvents:{compositionend:t=>{setTimeout((()=>{const{$cursor:o}=t.state.selection;o&&Ln({editor:e,from:o.pos,to:o.pos,text:"",rules:n,plugin:s})}));return false}},handleKeyDown(t,o){if(o.key!=="Enter")return false;const{$cursor:r}=t.state.selection;return!!r&&Ln({editor:e,from:r.pos,to:r.pos,text:"\n",rules:n,plugin:s})}},isInputRules:true});return s}function Bn(t){return Object.prototype.toString.call(t).slice(8,-1)}function Vn(t){return Bn(t)==="Object"&&(t.constructor===Object&&Object.getPrototypeOf(t)===Object.prototype)}function _n(t,e){const n={...t};Vn(t)&&Vn(e)&&Object.keys(e).forEach((s=>{Vn(e[s])&&Vn(t[s])?n[s]=_n(t[s],e[s]):n[s]=e[s]}));return n}var Un=class{constructor(t={}){this.type="extendable";this.parent=null;this.child=null;this.name="";this.config={name:this.name};this.config={...this.config,...t};this.name=this.config.name}get options(){return{...ye(me(this,"addOptions",{name:this.name}))||{}}}get storage(){return{...ye(me(this,"addStorage",{name:this.name,options:this.options}))||{}}}configure(t={}){const e=this.extend({...this.config,addOptions:()=>_n(this.options,t)});e.name=this.name;e.parent=this.parent;return e}extend(t={}){const e=new this.constructor({...this.config,...t});e.parent=this;this.child=e;e.name="name"in t?t.name:e.parent.name;return e}};var Wn=class _Mark extends Un{constructor(){super(...arguments);this.type="mark"}
/**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */static create(t={}){const e=typeof t==="function"?t():t;return new _Mark(e)}static handleExit({editor:t,mark:e}){const{tr:n}=t.state;const s=t.state.selection.$from;const o=s.pos===s.end();if(o){const o=s.marks();const r=!!o.find((t=>(t==null?void 0:t.type.name)===e.name));if(!r)return false;const i=o.find((t=>(t==null?void 0:t.type.name)===e.name));i&&n.removeStoredMark(i);n.insertText(" ",s.pos);t.view.dispatch(n);return true}return false}configure(t){return super.configure(t)}extend(t){const e=typeof t==="function"?t():t;return super.extend(e)}};function Fn(t){return typeof t==="number"}var Kn=class{constructor(t){this.find=t.find;this.handler=t.handler}};var qn=(t,e,n)=>{if(dt(e))return[...t.matchAll(e)];const s=e(t,n);return s?s.map((e=>{const n=[e.text];n.index=e.index;n.input=t;n.data=e.data;if(e.replaceWith){e.text.includes(e.replaceWith)||console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');n.push(e.replaceWith)}return n})):[]};function Jn(t){const{editor:e,state:n,from:s,to:o,rule:r,pasteEvent:i,dropEvent:a}=t;const{commands:c,chain:l,can:d}=new X({editor:e,state:n});const u=[];n.doc.nodesBetween(s,o,((t,e)=>{var p,h,m,f,g;if(((h=(p=t.type)==null?void 0:p.spec)==null?void 0:h.code)||!(t.isText||t.isTextblock||t.isInline))return;const v=(g=(f=(m=t.content)==null?void 0:m.size)!=null?f:t.nodeSize)!=null?g:0;const y=Math.max(s,e);const b=Math.min(o,e+v);if(y>=b)return;const w=t.isText?t.text||"":t.textBetween(y-e,b-e,void 0,"ï¿¼");const k=qn(w,r.find,i);k.forEach((t=>{if(t.index===void 0)return;const e=y+t.index+1;const s=e+t[0].length;const o={from:n.tr.mapping.map(e),to:n.tr.mapping.map(s)};const p=r.handler({state:n,range:o,match:t,commands:c,chain:l,can:d,pasteEvent:i,dropEvent:a});u.push(p)}))}));const p=u.every((t=>t!==null));return p}var Xn=null;var Yn=t=>{var e;const n=new ClipboardEvent("paste",{clipboardData:new DataTransfer});(e=n.clipboardData)==null?void 0:e.setData("text/html",t);return n};function Zn(t){const{editor:e,rules:n}=t;let s=null;let o=false;let r=false;let i=typeof ClipboardEvent!=="undefined"?new ClipboardEvent("paste"):null;let a;try{a=typeof DragEvent!=="undefined"?new DragEvent("drop"):null}catch{a=null}const c=({state:t,from:n,to:s,rule:o,pasteEvt:r})=>{const c=t.tr;const l=J({state:t,transaction:c});const d=Jn({editor:e,state:l,from:Math.max(n-1,0),to:s.b-1,rule:o,pasteEvent:r,dropEvent:a});if(d&&c.steps.length){try{a=typeof DragEvent!=="undefined"?new DragEvent("drop"):null}catch{a=null}i=typeof ClipboardEvent!=="undefined"?new ClipboardEvent("paste"):null;return c}};const l=n.map((t=>new P({view(t){const n=n=>{var o;s=((o=t.dom.parentElement)==null?void 0:o.contains(n.target))?t.dom.parentElement:null;s&&(Xn=e)};const o=()=>{Xn&&(Xn=null)};window.addEventListener("dragstart",n);window.addEventListener("dragend",o);return{destroy(){window.removeEventListener("dragstart",n);window.removeEventListener("dragend",o)}}},props:{handleDOMEvents:{drop:(t,e)=>{r=s===t.dom.parentElement;a=e;if(!r){const t=Xn;(t==null?void 0:t.isEditable)&&setTimeout((()=>{const e=t.state.selection;e&&t.commands.deleteRange({from:e.from,to:e.to})}),10)}return false},paste:(t,e)=>{var n;const s=(n=e.clipboardData)==null?void 0:n.getData("text/html");i=e;o=!!(s==null?void 0:s.includes("data-pm-slice"));return false}}},appendTransaction:(e,n,s)=>{const a=e[0];const l=a.getMeta("uiEvent")==="paste"&&!o;const d=a.getMeta("uiEvent")==="drop"&&!r;const u=a.getMeta("applyPasteRules");const p=!!u;if(!l&&!d&&!p)return;if(p){let{text:e}=u;typeof e==="string"?e:e=ge(j.from(e),s.schema);const{from:n}=u;const o=n+e.length;const r=Yn(e);return c({rule:t,state:s,from:n,to:{b:o},pasteEvt:r})}const h=n.doc.content.findDiffStart(s.doc.content);const m=n.doc.content.findDiffEnd(s.doc.content);return Fn(h)&&m&&h!==m.b?c({rule:t,state:s,from:h,to:m,pasteEvt:i}):void 0}})));return l}var Qn=class{constructor(t,e){this.splittableMarks=[];this.editor=e;this.baseExtensions=t;this.extensions=Ne(t);this.schema=Oe(this.extensions,e);this.setupExtensions()}
/**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */get commands(){return this.extensions.reduce(((t,e)=>{const n={name:e.name,options:e.options,storage:this.editor.extensionStorage[e.name],editor:this.editor,type:qe(e.name,this.schema)};const s=me(e,"addCommands",n);return s?{...t,...s()}:t}),{})}
/**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */get plugins(){const{editor:t}=this;const e=Ae([...this.extensions].reverse());const n=e.flatMap((e=>{const n={name:e.name,options:e.options,storage:this.editor.extensionStorage[e.name],editor:t,type:qe(e.name,this.schema)};const s=[];const o=me(e,"addKeyboardShortcuts",n);let r={};e.type==="mark"&&me(e,"exitable",n)&&(r.ArrowRight=()=>Wn.handleExit({editor:t,mark:e}));if(o){const e=Object.fromEntries(Object.entries(o()).map((([e,n])=>[e,()=>n({editor:t})])));r={...r,...e}}const i=F(r);s.push(i);const a=me(e,"addInputRules",n);if(tn(e,t.options.enableInputRules)&&a){const e=a();if(e&&e.length){const n=Hn({editor:t,rules:e});const o=Array.isArray(n)?n:[n];s.push(...o)}}const c=me(e,"addPasteRules",n);if(tn(e,t.options.enablePasteRules)&&c){const e=c();if(e&&e.length){const n=Zn({editor:t,rules:e});s.push(...n)}}const l=me(e,"addProseMirrorPlugins",n);if(l){const t=l();s.push(...t)}return s}));return n}
/**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */get attributes(){return ke(this.extensions)}
/**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */get nodeViews(){const{editor:t}=this;const{nodeExtensions:e}=we(this.extensions);return Object.fromEntries(e.filter((t=>!!me(t,"addNodeView"))).map((e=>{const n=this.attributes.filter((t=>t.type===e.name));const s={name:e.name,options:e.options,storage:this.editor.extensionStorage[e.name],editor:t,type:ot(e.name,this.schema)};const o=me(e,"addNodeView",s);if(!o)return[];const r=o();if(!r)return[];const i=(s,o,i,a,c)=>{const l=Me(s,n);return r({node:s,view:o,getPos:i,decorations:a,innerDecorations:c,editor:t,extension:e,HTMLAttributes:l})};return[e.name,i]})))}
/**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */dispatchTransaction(t){const{editor:e}=this;const n=Ae([...this.extensions].reverse());return n.reduceRight(((t,n)=>{const s={name:n.name,options:n.options,storage:this.editor.extensionStorage[n.name],editor:e,type:qe(n.name,this.schema)};const o=me(n,"dispatchTransaction",s);return o?e=>{o.call(s,{transaction:e,next:t})}:t}),t)}
/**
   * Get the composed transformPastedHTML function from all extensions.
   * @param baseTransform The base transform function (e.g. from the editor props)
   * @returns A composed transform function that chains all extension transforms
   */transformPastedHTML(t){const{editor:e}=this;const n=Ae([...this.extensions]);return n.reduce(((t,n)=>{const s={name:n.name,options:n.options,storage:this.editor.extensionStorage[n.name],editor:e,type:qe(n.name,this.schema)};const o=me(n,"transformPastedHTML",s);return o?(e,n)=>{const r=t(e,n);return o.call(s,r)}:t}),t||(t=>t))}get markViews(){const{editor:t}=this;const{markExtensions:e}=we(this.extensions);return Object.fromEntries(e.filter((t=>!!me(t,"addMarkView"))).map((e=>{const n=this.attributes.filter((t=>t.type===e.name));const s={name:e.name,options:e.options,storage:this.editor.extensionStorage[e.name],editor:t,type:ft(e.name,this.schema)};const o=me(e,"addMarkView",s);if(!o)return[];const r=(s,r,i)=>{const a=Me(s,n);return o()({mark:s,view:r,inline:i,editor:t,extension:e,HTMLAttributes:a,updateAttributes:e=>{Bs(s,t,e)}})};return[e.name,r]})))}setupExtensions(){const t=this.extensions;this.editor.extensionStorage=Object.fromEntries(t.map((t=>[t.name,t.storage])));t.forEach((t=>{var e;const n={name:t.name,options:t.options,storage:this.editor.extensionStorage[t.name],editor:this.editor,type:qe(t.name,this.schema)};if(t.type==="mark"){const s=(e=ye(me(t,"keepOnSplit",n)))==null||e;s&&this.splittableMarks.push(t.name)}const s=me(t,"onBeforeCreate",n);const o=me(t,"onCreate",n);const r=me(t,"onUpdate",n);const i=me(t,"onSelectionUpdate",n);const a=me(t,"onTransaction",n);const c=me(t,"onFocus",n);const l=me(t,"onBlur",n);const d=me(t,"onDestroy",n);s&&this.editor.on("beforeCreate",s);o&&this.editor.on("create",o);r&&this.editor.on("update",r);i&&this.editor.on("selectionUpdate",i);a&&this.editor.on("transaction",a);c&&this.editor.on("focus",c);l&&this.editor.on("blur",l);d&&this.editor.on("destroy",d)}))}};Qn.resolve=Ne;Qn.sort=Ae;Qn.flatten=fe;var Gn={};q(Gn,{ClipboardTextSerializer:()=>es,Commands:()=>ns,Delete:()=>ss,Drop:()=>os,Editable:()=>rs,FocusEvents:()=>as,Keymap:()=>cs,Paste:()=>ls,Tabindex:()=>ds,TextDirection:()=>us,focusEventsPluginKey:()=>is});var ts=class _Extension extends Un{constructor(){super(...arguments);this.type="extension"}
/**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */static create(t={}){const e=typeof t==="function"?t():t;return new _Extension(e)}configure(t){return super.configure(t)}extend(t){const e=typeof t==="function"?t():t;return super.extend(e)}};var es=ts.create({name:"clipboardTextSerializer",addOptions(){return{blockSeparator:void 0}},addProseMirrorPlugins(){return[new P({key:new z("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:t}=this;const{state:e,schema:n}=t;const{doc:s,selection:o}=e;const{ranges:r}=o;const i=Math.min(...r.map((t=>t.$from.pos)));const a=Math.max(...r.map((t=>t.$to.pos)));const c=Ie(n);const l={from:i,to:a};return De(s,l,{...this.options.blockSeparator!==void 0?{blockSeparator:this.options.blockSeparator}:{},textSerializers:c})}}})]}});var ns=ts.create({name:"commands",addCommands(){return{...Y}}});var ss=ts.create({name:"delete",onUpdate({transaction:t,appendedTransactions:e}){var n,s,o;const r=()=>{var n,s,o,r;if((r=(o=(s=(n=this.editor.options.coreExtensionOptions)==null?void 0:n.delete)==null?void 0:s.filterTransaction)==null?void 0:o.call(s,t))!=null?r:t.getMeta("y-sync$"))return;const i=ce(t.before,[t,...e]);const c=Ue(i);c.forEach((e=>{i.mapping.mapResult(e.oldRange.from).deletedAfter&&i.mapping.mapResult(e.oldRange.to).deletedBefore&&i.before.nodesBetween(e.oldRange.from,e.oldRange.to,((n,s)=>{const o=s+n.nodeSize-2;const r=e.oldRange.from<=s&&o<=e.oldRange.to;this.editor.emit("delete",{type:"node",node:n,from:s,to:o,newFrom:i.mapping.map(s),newTo:i.mapping.map(o),deletedRange:e.oldRange,newRange:e.newRange,partial:!r,editor:this.editor,transaction:t,combinedTransform:i})}))}));const l=i.mapping;i.steps.forEach(((e,n)=>{var s,o;if(e instanceof a){const r=l.slice(n).map(e.from,-1);const a=l.slice(n).map(e.to);const c=l.invert().map(r,-1);const d=l.invert().map(a);const u=(s=i.doc.nodeAt(r-1))==null?void 0:s.marks.some((t=>t.eq(e.mark)));const p=(o=i.doc.nodeAt(a))==null?void 0:o.marks.some((t=>t.eq(e.mark)));this.editor.emit("delete",{type:"mark",mark:e.mark,from:e.from,to:e.to,deletedRange:{from:c,to:d},newRange:{from:r,to:a},partial:Boolean(p||u),editor:this.editor,transaction:t,combinedTransform:i})}}))};(o=(s=(n=this.editor.options.coreExtensionOptions)==null?void 0:n.delete)==null?void 0:s.async)==null||o?setTimeout(r,0):r()}});var os=ts.create({name:"drop",addProseMirrorPlugins(){return[new P({key:new z("tiptapDrop"),props:{handleDrop:(t,e,n,s)=>{this.editor.emit("drop",{editor:this.editor,event:e,slice:n,moved:s})}}})]}});var rs=ts.create({name:"editable",addProseMirrorPlugins(){return[new P({key:new z("editable"),props:{editable:()=>this.editor.options.editable}})]}});var is=new z("focusEvents");var as=ts.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:t}=this;return[new P({key:is,props:{handleDOMEvents:{focus:(e,n)=>{t.isFocused=true;const s=t.state.tr.setMeta("focus",{event:n}).setMeta("addToHistory",false);e.dispatch(s);return false},blur:(e,n)=>{t.isFocused=false;const s=t.state.tr.setMeta("blur",{event:n}).setMeta("addToHistory",false);e.dispatch(s);return false}}}})]}});var cs=ts.create({name:"keymap",addKeyboardShortcuts(){const t=()=>this.editor.commands.first((({commands:t})=>[()=>t.undoInputRule(),()=>t.command((({tr:e})=>{const{selection:n,doc:s}=e;const{empty:o,$anchor:r}=n;const{pos:i,parent:a}=r;const c=r.parent.isTextblock&&i>0?e.doc.resolve(i-1):r;const l=c.parent.type.spec.isolating;const d=r.pos-r.parentOffset;const u=l&&c.parent.childCount===1?d===r.pos:$.atStart(s).from===i;return!(!o||!a.type.isTextblock||a.textContent.length||!u||u&&r.parent.type.name==="paragraph")&&t.clearNodes()})),()=>t.deleteSelection(),()=>t.joinBackward(),()=>t.selectNodeBackward()]));const e=()=>this.editor.commands.first((({commands:t})=>[()=>t.deleteSelection(),()=>t.deleteCurrentNode(),()=>t.joinForward(),()=>t.selectNodeForward()]));const n=()=>this.editor.commands.first((({commands:t})=>[()=>t.newlineInCode(),()=>t.createParagraphNear(),()=>t.liftEmptyBlock(),()=>t.splitBlock()]));const s={Enter:n,"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:t,"Mod-Backspace":t,"Shift-Backspace":t,Delete:e,"Mod-Delete":e,"Mod-a":()=>this.editor.commands.selectAll()};const o={...s};const r={...s,"Ctrl-h":t,"Alt-Backspace":t,"Ctrl-d":e,"Ctrl-Alt-Backspace":e,"Alt-Delete":e,"Alt-d":e,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return xt()||Vt()?r:o},addProseMirrorPlugins(){return[new P({key:new z("clearDocument"),appendTransaction:(t,e,n)=>{if(t.some((t=>t.getMeta("composition"))))return;const s=t.some((t=>t.docChanged))&&!e.doc.eq(n.doc);const o=t.some((t=>t.getMeta("preventClearDocument")));if(!s||o)return;const{empty:r,from:i,to:a}=e.selection;const c=$.atStart(e.doc).from;const l=$.atEnd(e.doc).to;const d=i===c&&a===l;if(r||!d)return;const u=nn(n.doc);if(!u)return;const p=n.tr;const h=J({state:n,transaction:p});const{commands:m}=new X({editor:this.editor,state:h});m.clearNodes();return p.steps.length?p:void 0}})]}});var ls=ts.create({name:"paste",addProseMirrorPlugins(){return[new P({key:new z("tiptapPaste"),props:{handlePaste:(t,e,n)=>{this.editor.emit("paste",{editor:this.editor,event:e,slice:n})}}})]}});var ds=ts.create({name:"tabindex",addProseMirrorPlugins(){return[new P({key:new z("tabindex"),props:{attributes:()=>this.editor.isEditable?{tabindex:"0"}:{}}})]}});var us=ts.create({name:"textDirection",addOptions(){return{direction:void 0}},addGlobalAttributes(){if(!this.options.direction)return[];const{nodeExtensions:t}=we(this.extensions);return[{types:t.filter((t=>t.name!=="text")).map((t=>t.name)),attributes:{dir:{default:this.options.direction,parseHTML:t=>{const e=t.getAttribute("dir");return!e||e!=="ltr"&&e!=="rtl"&&e!=="auto"?this.options.direction:e},renderHTML:t=>t.dir?{dir:t.dir}:{}}}}]},addProseMirrorPlugins(){return[new P({key:new z("textDirection"),props:{attributes:()=>{const t=this.options.direction;return t?{dir:t}:{}}}})]}});var ps=class _NodePos{constructor(t,e,n=false,s=null){this.currentNode=null;this.actualDepth=null;this.isBlock=n;this.resolvedPos=t;this.editor=e;this.currentNode=s}get name(){return this.node.type.name}get node(){return this.currentNode||this.resolvedPos.node()}get element(){return this.editor.view.domAtPos(this.pos).node}get depth(){var t;return(t=this.actualDepth)!=null?t:this.resolvedPos.depth}get pos(){return this.resolvedPos.pos}get content(){return this.node.content}set content(t){let e=this.from;let n=this.to;if(this.isBlock){if(this.content.size===0){console.error(`You canât set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);return}e=this.from+1;n=this.to-1}this.editor.commands.insertContentAt({from:e,to:n},t)}get attributes(){return this.node.attrs}get textContent(){return this.node.textContent}get size(){return this.node.nodeSize}get from(){return this.isBlock?this.pos:this.resolvedPos.start(this.resolvedPos.depth)}get range(){return{from:this.from,to:this.to}}get to(){return this.isBlock?this.pos+this.size:this.resolvedPos.end(this.resolvedPos.depth)+(this.node.isText?0:1)}get parent(){if(this.depth===0)return null;const t=this.resolvedPos.start(this.resolvedPos.depth-1);const e=this.resolvedPos.doc.resolve(t);return new _NodePos(e,this.editor)}get before(){let t=this.resolvedPos.doc.resolve(this.from-(this.isBlock?1:2));t.depth!==this.depth&&(t=this.resolvedPos.doc.resolve(this.from-3));return new _NodePos(t,this.editor)}get after(){let t=this.resolvedPos.doc.resolve(this.to+(this.isBlock?2:1));t.depth!==this.depth&&(t=this.resolvedPos.doc.resolve(this.to+3));return new _NodePos(t,this.editor)}get children(){const t=[];this.node.content.forEach(((e,n)=>{const s=e.isBlock&&!e.isTextblock;const o=e.isAtom&&!e.isText;const r=e.isInline;const i=this.pos+n+(o?0:1);if(i<0||i>this.resolvedPos.doc.nodeSize-2)return;const a=this.resolvedPos.doc.resolve(i);if(!s&&!r&&a.depth<=this.depth)return;const c=new _NodePos(a,this.editor,s,s||r?e:null);s&&(c.actualDepth=this.depth+1);t.push(c)}));return t}get firstChild(){return this.children[0]||null}get lastChild(){const t=this.children;return t[t.length-1]||null}closest(t,e={}){let n=null;let s=this.parent;while(s&&!n){if(s.node.type.name===t)if(Object.keys(e).length>0){const t=s.node.attrs;const n=Object.keys(e);for(let s=0;s<n.length;s+=1){const o=n[s];if(t[o]!==e[o])break}}else n=s;s=s.parent}return n}querySelector(t,e={}){return this.querySelectorAll(t,e,true)[0]||null}querySelectorAll(t,e={},n=false){let s=[];if(!this.children||this.children.length===0)return s;const o=Object.keys(e);this.children.forEach((r=>{if(!(n&&s.length>0)){if(r.node.type.name===t){const t=o.every((t=>e[t]===r.node.attrs[t]));t&&s.push(r)}n&&s.length>0||(s=s.concat(r.querySelectorAll(t,e,n)))}}));return s}setAttribute(t){const{tr:e}=this.editor.state;e.setNodeMarkup(this.from,void 0,{...this.node.attrs,...t});this.editor.view.dispatch(e)}};var hs='.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}';function ms(t,e,n){const s=document.querySelector(`style[data-tiptap-style${n?`-${n}`:""}]`);if(s!==null)return s;const o=document.createElement("style");e&&o.setAttribute("nonce",e);o.setAttribute("data-tiptap-style"+(n?`-${n}`:""),"");o.innerHTML=t;document.getElementsByTagName("head")[0].appendChild(o);return o}var fs=class extends Dn{constructor(t={}){super();this.css=null;this.className="tiptap";this.editorView=null;this.isFocused=false;this.isInitialized=false;this.extensionStorage={};this.instanceId=Math.random().toString(36).slice(2,9);this.options={element:typeof document!=="undefined"?document.createElement("div"):null,content:"",injectCSS:true,injectNonce:void 0,extensions:[],autofocus:false,editable:true,textDirection:void 0,editorProps:{},parseOptions:{},coreExtensionOptions:{},enableInputRules:true,enablePasteRules:true,enableCoreExtensions:true,enableContentCheck:false,emitContentError:false,onBeforeCreate:()=>null,onCreate:()=>null,onMount:()=>null,onUnmount:()=>null,onUpdate:()=>null,onSelectionUpdate:()=>null,onTransaction:()=>null,onFocus:()=>null,onBlur:()=>null,onDestroy:()=>null,onContentError:({error:t})=>{throw t},onPaste:()=>null,onDrop:()=>null,onDelete:()=>null,enableExtensionDispatchTransaction:true};this.isCapturingTransaction=false;this.capturedTransaction=null;this.utils={getUpdatedPosition:rn,createMappablePosition:an};this.setOptions(t);this.createExtensionManager();this.createCommandManager();this.createSchema();this.on("beforeCreate",this.options.onBeforeCreate);this.emit("beforeCreate",{editor:this});this.on("mount",this.options.onMount);this.on("unmount",this.options.onUnmount);this.on("contentError",this.options.onContentError);this.on("create",this.options.onCreate);this.on("update",this.options.onUpdate);this.on("selectionUpdate",this.options.onSelectionUpdate);this.on("transaction",this.options.onTransaction);this.on("focus",this.options.onFocus);this.on("blur",this.options.onBlur);this.on("destroy",this.options.onDestroy);this.on("drop",(({event:t,slice:e,moved:n})=>this.options.onDrop(t,e,n)));this.on("paste",(({event:t,slice:e})=>this.options.onPaste(t,e)));this.on("delete",this.options.onDelete);const e=this.createDoc();const n=wt(e,this.options.autofocus);this.editorState=R.create({doc:e,schema:this.schema,selection:n||void 0});this.options.element&&this.mount(this.options.element)}mount(t){if(typeof document==="undefined")throw new Error("[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.");this.createView(t);this.emit("mount",{editor:this});this.css&&!document.head.contains(this.css)&&document.head.appendChild(this.css);window.setTimeout((()=>{if(!this.isDestroyed){this.options.autofocus!==false&&this.options.autofocus!==null&&this.commands.focus(this.options.autofocus);this.emit("create",{editor:this});this.isInitialized=true}}),0)}unmount(){if(this.editorView){const t=this.editorView.dom;(t==null?void 0:t.editor)&&delete t.editor;this.editorView.destroy()}this.editorView=null;this.isInitialized=false;if(this.css&&!document.querySelectorAll(`.${this.className}`).length)try{typeof this.css.remove==="function"?this.css.remove():this.css.parentNode&&this.css.parentNode.removeChild(this.css)}catch(t){console.warn("Failed to remove CSS element:",t)}this.css=null;this.emit("unmount",{editor:this})}get storage(){return this.extensionStorage}get commands(){return this.commandManager.commands}chain(){return this.commandManager.chain()}can(){return this.commandManager.can()}injectCSS(){this.options.injectCSS&&typeof document!=="undefined"&&(this.css=ms(hs,this.options.injectNonce))}
/**
   * Update editor options.
   *
   * @param options A list of options
   */setOptions(t={}){this.options={...this.options,...t};if(this.editorView&&this.state&&!this.isDestroyed){this.options.editorProps&&this.view.setProps(this.options.editorProps);this.view.updateState(this.state)}}setEditable(t,e=true){this.setOptions({editable:t});e&&this.emit("update",{editor:this,transaction:this.state.tr,appendedTransactions:[]})}get isEditable(){return this.options.editable&&this.view&&this.view.editable}get view(){return this.editorView?this.editorView:new Proxy({state:this.editorState,updateState:t=>{this.editorState=t},dispatch:t=>{this.dispatchTransaction(t)},composing:false,dragging:null,editable:true,isDestroyed:false},{get:(t,e)=>{if(this.editorView)return this.editorView[e];if(e==="state")return this.editorState;if(e in t)return Reflect.get(t,e);throw new Error(`[tiptap error]: The editor view is not available. Cannot access view['${e}']. The editor may not be mounted yet.`)}})}get state(){this.editorView&&(this.editorState=this.view.state);return this.editorState}
/**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */registerPlugin(t,e){const n=ve(e)?e(t,[...this.state.plugins]):[...this.state.plugins,t];const s=this.state.reconfigure({plugins:n});this.view.updateState(s);return s}
/**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */unregisterPlugin(t){if(this.isDestroyed)return;const e=this.state.plugins;let n=e;[].concat(t).forEach((t=>{const e=typeof t==="string"?`${t}$`:t.key;n=n.filter((t=>!t.key.startsWith(e)))}));if(e.length===n.length)return;const s=this.state.reconfigure({plugins:n});this.view.updateState(s);return s}createExtensionManager(){var t,e;const n=this.options.enableCoreExtensions?[rs,es.configure({blockSeparator:(e=(t=this.options.coreExtensionOptions)==null?void 0:t.clipboardTextSerializer)==null?void 0:e.blockSeparator}),ns,as,cs,ds,os,ls,ss,us.configure({direction:this.options.textDirection})].filter((t=>typeof this.options.enableCoreExtensions!=="object"||this.options.enableCoreExtensions[t.name]!==false)):[];const s=[...n,...this.options.extensions].filter((t=>["extension","node","mark"].includes(t==null?void 0:t.type)));this.extensionManager=new Qn(s,this)}createCommandManager(){this.commandManager=new X({editor:this})}createSchema(){this.schema=this.extensionManager.schema}createDoc(){let t;try{t=re(this.options.content,this.schema,this.options.parseOptions,{errorOnInvalidContent:this.options.enableContentCheck})}catch(e){if(!(e instanceof Error)||!["[tiptap error]: Invalid JSON content","[tiptap error]: Invalid HTML content"].includes(e.message))throw e;this.emit("contentError",{editor:this,error:e,disableCollaboration:()=>{"collaboration"in this.storage&&typeof this.storage.collaboration==="object"&&this.storage.collaboration&&(this.storage.collaboration.isDisabled=true);this.options.extensions=this.options.extensions.filter((t=>t.name!=="collaboration"));this.createExtensionManager()}});t=re(this.options.content,this.schema,this.options.parseOptions,{errorOnInvalidContent:false})}return t}createView(t){const{editorProps:e,enableExtensionDispatchTransaction:n}=this.options;const s=e.dispatchTransaction||this.dispatchTransaction.bind(this);const o=n?this.extensionManager.dispatchTransaction(s):s;const r=e.transformPastedHTML;const i=this.extensionManager.transformPastedHTML(r);this.editorView=new W(t,{...e,attributes:{role:"textbox",...e==null?void 0:e.attributes},dispatchTransaction:o,transformPastedHTML:i,state:this.editorState,markViews:this.extensionManager.markViews,nodeViews:this.extensionManager.nodeViews});const a=this.state.reconfigure({plugins:this.extensionManager.plugins});this.view.updateState(a);this.prependClass();this.injectCSS();const c=this.view.dom;c.editor=this}createNodeViews(){this.view.isDestroyed||this.view.setProps({markViews:this.extensionManager.markViews,nodeViews:this.extensionManager.nodeViews})}prependClass(){this.view.dom.className=`${this.className} ${this.view.dom.className}`}captureTransaction(t){this.isCapturingTransaction=true;t();this.isCapturingTransaction=false;const e=this.capturedTransaction;this.capturedTransaction=null;return e}
/**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */dispatchTransaction(t){if(this.view.isDestroyed)return;if(this.isCapturingTransaction){if(!this.capturedTransaction){this.capturedTransaction=t;return}t.steps.forEach((t=>{var e;return(e=this.capturedTransaction)==null?void 0:e.step(t)}));return}const{state:e,transactions:n}=this.state.applyTransaction(t);const s=!this.state.selection.eq(e.selection);const o=n.includes(t);const r=this.state;this.emit("beforeTransaction",{editor:this,transaction:t,nextState:e});if(!o)return;this.view.updateState(e);this.emit("transaction",{editor:this,transaction:t,appendedTransactions:n.slice(1)});s&&this.emit("selectionUpdate",{editor:this,transaction:t});const i=n.findLast((t=>t.getMeta("focus")||t.getMeta("blur")));const a=i==null?void 0:i.getMeta("focus");const c=i==null?void 0:i.getMeta("blur");a&&this.emit("focus",{editor:this,event:a.event,transaction:i});c&&this.emit("blur",{editor:this,event:c.event,transaction:i});t.getMeta("preventUpdate")||!n.some((t=>t.docChanged))||r.doc.eq(e.doc)||this.emit("update",{editor:this,transaction:t,appendedTransactions:n.slice(1)})}getAttributes(t){return Be(this.state,t)}isActive(t,e){const n=typeof t==="string"?t:null;const s=typeof t==="string"?e:t;return Ze(this.state,n,s)}getJSON(){return this.state.doc.toJSON()}getHTML(){return ge(this.state.doc.content,this.schema)}getText(t){const{blockSeparator:e="\n\n",textSerializers:n={}}=t||{};return je(this.state.doc,{blockSeparator:e,textSerializers:{...Ie(this.schema),...n}})}get isEmpty(){return nn(this.state.doc)}destroy(){this.emit("destroy");this.unmount();this.removeAllListeners()}get isDestroyed(){var t,e;return(e=(t=this.editorView)==null?void 0:t.isDestroyed)==null||e}$node(t,e){var n;return((n=this.$doc)==null?void 0:n.querySelector(t,e))||null}$nodes(t,e){var n;return((n=this.$doc)==null?void 0:n.querySelectorAll(t,e))||null}$pos(t){const e=this.state.doc.resolve(t);return new ps(e,this)}get $doc(){return this.$pos(0)}};function gs(t){return new jn({find:t.find,handler:({state:e,range:n,match:s})=>{const o=ye(t.getAttributes,void 0,s);if(o===false||o===null)return null;const{tr:r}=e;const i=s[s.length-1];const a=s[0];if(i){const s=a.search(/\S/);const c=n.from+a.indexOf(i);const l=c+i.length;const d=Fe(n.from,n.to,e.doc).filter((e=>{const n=e.mark.type.excluded;return n.find((n=>n===t.type&&n!==e.mark.type))})).filter((t=>t.to>c));if(d.length)return null;l<n.to&&r.delete(l,n.to);c>n.from&&r.delete(n.from+s,c);const u=n.from+s+i.length;r.addMark(n.from+s,u,t.type.create(o||{}));r.removeStoredMark(t.type)}},undoable:t.undoable})}function vs(t){return new jn({find:t.find,handler:({state:e,range:n,match:s})=>{const o=ye(t.getAttributes,void 0,s)||{};const{tr:r}=e;const i=n.from;let a=n.to;const c=t.type.create(o);if(s[1]){const t=s[0].lastIndexOf(s[1]);let e=i+t;e>a?e=a:a=e+s[1].length;const n=s[0][s[0].length-1];r.insertText(n,i+s[0].length-1);r.replaceWith(e,a,c)}else if(s[0]){const e=t.type.isInline?i:i-1;r.insert(e,t.type.create(o)).delete(r.mapping.map(i),r.mapping.map(a))}r.scrollIntoView()},undoable:t.undoable})}function ys(t){return new jn({find:t.find,handler:({state:e,range:n,match:s})=>{const o=e.doc.resolve(n.from);const r=ye(t.getAttributes,void 0,s)||{};if(!o.node(-1).canReplaceWith(o.index(-1),o.indexAfter(-1),t.type))return null;e.tr.delete(n.from,n.to).setBlockType(n.from,n.from,t.type,r)},undoable:t.undoable})}function bs(t){return new jn({find:t.find,handler:({state:e,range:n,match:s})=>{let o=t.replace;let r=n.from;const i=n.to;if(s[1]){const t=s[0].lastIndexOf(s[1]);o+=s[0].slice(t+s[1].length);r+=t;const e=r-i;if(e>0){o=s[0].slice(t-e,t)+o;r=i}}e.tr.insertText(o,r,i)},undoable:t.undoable})}function ws(t){return new jn({find:t.find,handler:({state:e,range:n,match:s,chain:o})=>{const r=ye(t.getAttributes,void 0,s)||{};const a=e.tr.delete(n.from,n.to);const l=a.doc.resolve(n.from);const d=l.blockRange();const u=d&&c(d,t.type,r);if(!u)return null;a.wrap(d,u);if(t.keepMarks&&t.editor){const{selection:n,storedMarks:s}=e;const{splittableMarks:o}=t.editor.extensionManager;const r=s||n.$to.parentOffset&&n.$from.marks();if(r){const t=r.filter((t=>o.includes(t.type.name)));a.ensureMarks(t)}}if(t.keepAttributes){const e=t.type.name==="bulletList"||t.type.name==="orderedList"?"listItem":"taskList";o().updateAttributes(e,r).run()}const p=a.doc.resolve(n.from-1).nodeBefore;p&&p.type===t.type&&i(a.doc,n.from-1)&&(!t.joinPredicate||t.joinPredicate(s,p))&&a.join(n.from-1)},undoable:t.undoable})}function ks(t){return t.children}var xs=(t,e)=>{if(t==="slot")return 0;if(t instanceof Function)return t(e);const{children:n,...s}=e!=null?e:{};if(t==="svg")throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");return[t,s,n]};var Ms=t=>"touches"in t;var Es=class{
/**
   * Creates a new ResizableNodeView instance.
   *
   * The constructor sets up the resize handles, applies initial sizing from
   * node attributes, and configures all resize behavior options.
   *
   * @param options - Configuration options for the resizable node view
   */
constructor(t){this.directions=["bottom-left","bottom-right","top-left","top-right"];this.minSize={height:8,width:8};this.preserveAspectRatio=false;this.classNames={container:"",wrapper:"",handle:"",resizing:""};this.initialWidth=0;this.initialHeight=0;this.aspectRatio=1;this.isResizing=false;this.activeHandle=null;this.startX=0;this.startY=0;this.startWidth=0;this.startHeight=0;this.isShiftKeyPressed=false;this.lastEditableState=void 0;this.handleMap=new Map;
/**
     * Handles mouse movement during an active resize.
     *
     * Calculates the delta from the starting position, computes new dimensions
     * based on the active handle direction, applies constraints and aspect ratio,
     * then updates the element's style and calls the onResize callback.
     *
     * @param event - The mouse move event
     */this.handleMouseMove=t=>{if(!this.isResizing||!this.activeHandle)return;const e=t.clientX-this.startX;const n=t.clientY-this.startY;this.handleResize(e,n)};this.handleTouchMove=t=>{if(!this.isResizing||!this.activeHandle)return;const e=t.touches[0];if(!e)return;const n=e.clientX-this.startX;const s=e.clientY-this.startY;this.handleResize(n,s)};this.handleMouseUp=()=>{if(!this.isResizing)return;const t=this.element.offsetWidth;const e=this.element.offsetHeight;this.onCommit(t,e);this.isResizing=false;this.activeHandle=null;this.container.dataset.resizeState="false";this.classNames.resizing&&this.container.classList.remove(this.classNames.resizing);document.removeEventListener("mousemove",this.handleMouseMove);document.removeEventListener("mouseup",this.handleMouseUp);document.removeEventListener("keydown",this.handleKeyDown);document.removeEventListener("keyup",this.handleKeyUp)};
/**
     * Tracks Shift key state to enable temporary aspect ratio locking.
     *
     * When Shift is pressed during resize, aspect ratio is preserved even if
     * preserveAspectRatio is false.
     *
     * @param event - The keyboard event
     */this.handleKeyDown=t=>{t.key==="Shift"&&(this.isShiftKeyPressed=true)};
/**
     * Tracks Shift key release to disable temporary aspect ratio locking.
     *
     * @param event - The keyboard event
     */this.handleKeyUp=t=>{t.key==="Shift"&&(this.isShiftKeyPressed=false)};var e,n,s,o,r,i;this.node=t.node;this.editor=t.editor;this.element=t.element;this.contentElement=t.contentElement;this.getPos=t.getPos;this.onResize=t.onResize;this.onCommit=t.onCommit;this.onUpdate=t.onUpdate;((e=t.options)==null?void 0:e.min)&&(this.minSize={...this.minSize,...t.options.min});((n=t.options)==null?void 0:n.max)&&(this.maxSize=t.options.max);((s=t==null?void 0:t.options)==null?void 0:s.directions)&&(this.directions=t.options.directions);((o=t.options)==null?void 0:o.preserveAspectRatio)&&(this.preserveAspectRatio=t.options.preserveAspectRatio);((r=t.options)==null?void 0:r.className)&&(this.classNames={container:t.options.className.container||"",wrapper:t.options.className.wrapper||"",handle:t.options.className.handle||"",resizing:t.options.className.resizing||""});((i=t.options)==null?void 0:i.createCustomHandle)&&(this.createCustomHandle=t.options.createCustomHandle);this.wrapper=this.createWrapper();this.container=this.createContainer();this.applyInitialSize();this.attachHandles();this.editor.on("update",this.handleEditorUpdate.bind(this))}
/**
   * Returns the top-level DOM node that should be placed in the editor.
   *
   * This is required by the ProseMirror NodeView interface. The container
   * includes the wrapper, handles, and the actual content element.
   *
   * @returns The container element to be inserted into the editor
   */get dom(){return this.container}get contentDOM(){var t;return(t=this.contentElement)!=null?t:null}handleEditorUpdate(){const t=this.editor.isEditable;if(t!==this.lastEditableState){this.lastEditableState=t;t?t&&this.handleMap.size===0&&this.attachHandles():this.removeHandles()}}
/**
   * Called when the node's content or attributes change.
   *
   * Updates the internal node reference. If a custom `onUpdate` callback
   * was provided, it will be called to handle additional update logic.
   *
   * @param node - The new/updated node
   * @param decorations - Node decorations
   * @param innerDecorations - Inner decorations
   * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`
   */update(t,e,n){if(t.type!==this.node.type)return false;this.node=t;return!this.onUpdate||this.onUpdate(t,e,n)}destroy(){if(this.isResizing){this.container.dataset.resizeState="false";this.classNames.resizing&&this.container.classList.remove(this.classNames.resizing);document.removeEventListener("mousemove",this.handleMouseMove);document.removeEventListener("mouseup",this.handleMouseUp);document.removeEventListener("keydown",this.handleKeyDown);document.removeEventListener("keyup",this.handleKeyUp);this.isResizing=false;this.activeHandle=null}this.editor.off("update",this.handleEditorUpdate.bind(this));this.container.remove()}
/**
   * Creates the outer container element.
   *
   * The container is the top-level element returned by the NodeView and
   * wraps the entire resizable node. It's set up with flexbox to handle
   * alignment and includes data attributes for styling and identification.
   *
   * @returns The container element
   */createContainer(){const t=document.createElement("div");t.dataset.resizeContainer="";t.dataset.node=this.node.type.name;t.style.display="flex";this.classNames.container&&(t.className=this.classNames.container);t.appendChild(this.wrapper);return t}
/**
   * Creates the wrapper element that contains the content and handles.
   *
   * The wrapper uses relative positioning so that resize handles can be
   * positioned absolutely within it. This is the direct parent of the
   * content element being made resizable.
   *
   * @returns The wrapper element
   */createWrapper(){const t=document.createElement("div");t.style.position="relative";t.style.display="block";t.dataset.resizeWrapper="";this.classNames.wrapper&&(t.className=this.classNames.wrapper);t.appendChild(this.element);return t}
/**
   * Creates a resize handle element for a specific direction.
   *
   * Each handle is absolutely positioned and includes a data attribute
   * identifying its direction for styling purposes.
   *
   * @param direction - The resize direction for this handle
   * @returns The handle element
   */createHandle(t){const e=document.createElement("div");e.dataset.resizeHandle=t;e.style.position="absolute";this.classNames.handle&&(e.className=this.classNames.handle);return e}
/**
   * Positions a handle element according to its direction.
   *
   * Corner handles (e.g., 'top-left') are positioned at the intersection
   * of two edges. Edge handles (e.g., 'top') span the full width or height.
   *
   * @param handle - The handle element to position
   * @param direction - The direction determining the position
   */positionHandle(t,e){const n=e.includes("top");const s=e.includes("bottom");const o=e.includes("left");const r=e.includes("right");n&&(t.style.top="0");s&&(t.style.bottom="0");o&&(t.style.left="0");r&&(t.style.right="0");if(e==="top"||e==="bottom"){t.style.left="0";t.style.right="0"}if(e==="left"||e==="right"){t.style.top="0";t.style.bottom="0"}}attachHandles(){this.directions.forEach((t=>{let e;e=this.createCustomHandle?this.createCustomHandle(t):this.createHandle(t);if(!(e instanceof HTMLElement)){console.warn(`[ResizableNodeView] createCustomHandle("${t}") did not return an HTMLElement. Falling back to default handle.`);e=this.createHandle(t)}this.createCustomHandle||this.positionHandle(e,t);e.addEventListener("mousedown",(e=>this.handleResizeStart(e,t)));e.addEventListener("touchstart",(e=>this.handleResizeStart(e,t)));this.handleMap.set(t,e);this.wrapper.appendChild(e)}))}removeHandles(){this.handleMap.forEach((t=>t.remove()));this.handleMap.clear()}applyInitialSize(){const t=this.node.attrs.width;const e=this.node.attrs.height;if(t){this.element.style.width=`${t}px`;this.initialWidth=t}else this.initialWidth=this.element.offsetWidth;if(e){this.element.style.height=`${e}px`;this.initialHeight=e}else this.initialHeight=this.element.offsetHeight;this.initialWidth>0&&this.initialHeight>0&&(this.aspectRatio=this.initialWidth/this.initialHeight)}
/**
   * Initiates a resize operation when a handle is clicked.
   *
   * Captures the starting mouse position and element dimensions, sets up
   * the resize state, adds the resizing class and state attribute, and
   * attaches document-level listeners for mouse movement and keyboard input.
   *
   * @param event - The mouse down event
   * @param direction - The direction of the handle being dragged
   */handleResizeStart(t,e){t.preventDefault();t.stopPropagation();this.isResizing=true;this.activeHandle=e;if(Ms(t)){this.startX=t.touches[0].clientX;this.startY=t.touches[0].clientY}else{this.startX=t.clientX;this.startY=t.clientY}this.startWidth=this.element.offsetWidth;this.startHeight=this.element.offsetHeight;this.startWidth>0&&this.startHeight>0&&(this.aspectRatio=this.startWidth/this.startHeight);const n=this.getPos();n!==void 0;this.container.dataset.resizeState="true";this.classNames.resizing&&this.container.classList.add(this.classNames.resizing);document.addEventListener("mousemove",this.handleMouseMove);document.addEventListener("touchmove",this.handleTouchMove);document.addEventListener("mouseup",this.handleMouseUp);document.addEventListener("keydown",this.handleKeyDown);document.addEventListener("keyup",this.handleKeyUp)}handleResize(t,e){if(!this.activeHandle)return;const n=this.preserveAspectRatio||this.isShiftKeyPressed;const{width:s,height:o}=this.calculateNewDimensions(this.activeHandle,t,e);const r=this.applyConstraints(s,o,n);this.element.style.width=`${r.width}px`;this.element.style.height=`${r.height}px`;this.onResize&&this.onResize(r.width,r.height)}
/**
   * Calculates new dimensions based on mouse delta and resize direction.
   *
   * Takes the starting dimensions and applies the mouse movement delta
   * according to the handle direction. For corner handles, both dimensions
   * are affected. For edge handles, only one dimension changes. If aspect
   * ratio should be preserved, delegates to applyAspectRatio.
   *
   * @param direction - The active resize handle direction
   * @param deltaX - Horizontal mouse movement since resize start
   * @param deltaY - Vertical mouse movement since resize start
   * @returns The calculated width and height
   */calculateNewDimensions(t,e,n){let s=this.startWidth;let o=this.startHeight;const r=t.includes("right");const i=t.includes("left");const a=t.includes("bottom");const c=t.includes("top");r?s=this.startWidth+e:i&&(s=this.startWidth-e);a?o=this.startHeight+n:c&&(o=this.startHeight-n);t!=="right"&&t!=="left"||(s=this.startWidth+(r?e:-e));t!=="top"&&t!=="bottom"||(o=this.startHeight+(a?n:-n));const l=this.preserveAspectRatio||this.isShiftKeyPressed;return l?this.applyAspectRatio(s,o,t):{width:s,height:o}}
/**
   * Applies min/max constraints to dimensions.
   *
   * When aspect ratio is NOT preserved, constraints are applied independently
   * to width and height. When aspect ratio IS preserved, constraints are
   * applied while maintaining the aspect ratioâif one dimension hits a limit,
   * the other is recalculated proportionally.
   *
   * This ensures that aspect ratio is never broken when constrained.
   *
   * @param width - The unconstrained width
   * @param height - The unconstrained height
   * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining
   * @returns The constrained dimensions
   */applyConstraints(t,e,n){var s,o,r,i;if(!n){let n=Math.max(this.minSize.width,t);let r=Math.max(this.minSize.height,e);((s=this.maxSize)==null?void 0:s.width)&&(n=Math.min(this.maxSize.width,n));((o=this.maxSize)==null?void 0:o.height)&&(r=Math.min(this.maxSize.height,r));return{width:n,height:r}}let a=t;let c=e;if(a<this.minSize.width){a=this.minSize.width;c=a/this.aspectRatio}if(c<this.minSize.height){c=this.minSize.height;a=c*this.aspectRatio}if(((r=this.maxSize)==null?void 0:r.width)&&a>this.maxSize.width){a=this.maxSize.width;c=a/this.aspectRatio}if(((i=this.maxSize)==null?void 0:i.height)&&c>this.maxSize.height){c=this.maxSize.height;a=c*this.aspectRatio}return{width:a,height:c}}
/**
   * Adjusts dimensions to maintain the original aspect ratio.
   *
   * For horizontal handles (left/right), uses width as the primary dimension
   * and calculates height from it. For vertical handles (top/bottom), uses
   * height as primary and calculates width. For corner handles, uses width
   * as the primary dimension.
   *
   * @param width - The new width
   * @param height - The new height
   * @param direction - The active resize direction
   * @returns Dimensions adjusted to preserve aspect ratio
   */applyAspectRatio(t,e,n){const s=n==="left"||n==="right";const o=n==="top"||n==="bottom";return s?{width:t,height:t/this.aspectRatio}:o?{width:e*this.aspectRatio,height:e}:{width:t,height:t/this.aspectRatio}}};var Ss=Es;function Cs(t,e){const{selection:n}=t;const{$from:s}=n;if(n instanceof N){const t=s.index();const n=s.parent;return n.canReplaceWith(t,t+1,e)}let o=s.depth;while(o>=0){const t=s.index(o);const n=s.node(o);const r=n.contentMatchAt(t);if(r.matchType(e))return true;o-=1}return false}function Ts(t){return t.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function Os(){return typeof navigator!=="undefined"&&/Firefox/.test(navigator.userAgent)}function $s(t){return typeof t==="string"}var As={};q(As,{createAtomBlockMarkdownSpec:()=>zs,createBlockMarkdownSpec:()=>Rs,createInlineMarkdownSpec:()=>Is,parseAttributes:()=>Ns,parseIndentedBlocks:()=>Ls,renderNestedMarkdownContent:()=>Hs,serializeAttributes:()=>Ps});function Ns(t){if(!(t==null?void 0:t.trim()))return{};const e={};const n=[];const s=t.replace(/["']([^"']*)["']/g,(t=>{n.push(t);return`__QUOTED_${n.length-1}__`}));const o=s.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);if(o){const t=o.map((t=>t.trim().slice(1)));e.class=t.join(" ")}const r=s.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);r&&(e.id=r[1]);const i=/([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;const a=Array.from(s.matchAll(i));a.forEach((([,t,s])=>{var o;const r=parseInt(((o=s.match(/__QUOTED_(\d+)__/))==null?void 0:o[1])||"0",10);const i=n[r];i&&(e[t]=i.slice(1,-1))}));const c=s.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g,"").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g,"").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g,"").trim();if(c){const t=c.split(/\s+/).filter(Boolean);t.forEach((t=>{t.match(/^[a-zA-Z][\w-]*$/)&&(e[t]=true)}))}return e}function Ps(t){if(!t||Object.keys(t).length===0)return"";const e=[];if(t.class){const n=String(t.class).split(/\s+/).filter(Boolean);n.forEach((t=>e.push(`.${t}`)))}t.id&&e.push(`#${t.id}`);Object.entries(t).forEach((([t,n])=>{t!=="class"&&t!=="id"&&(n===true?e.push(t):n!==false&&n!=null&&e.push(`${t}="${String(n)}"`))}));return e.join(" ")}function zs(t){const{nodeName:e,name:n,parseAttributes:s=Ns,serializeAttributes:o=Ps,defaultAttributes:r={},requiredAttributes:i=[],allowedAttributes:a}=t;const c=n||e;const l=t=>{if(!a)return t;const e={};a.forEach((n=>{n in t&&(e[n]=t[n])}));return e};return{parseMarkdown:(t,n)=>{const s={...r,...t.attributes};return n.createNode(e,s,[])},markdownTokenizer:{name:e,level:"block",start(t){var e;const n=new RegExp(`^:::${c}(?:\\s|$)`,"m");const s=(e=t.match(n))==null?void 0:e.index;return s!==void 0?s:-1},tokenize(t,n,o){const r=new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`);const a=t.match(r);if(!a)return;const l=a[1]||"";const d=s(l);const u=i.find((t=>!(t in d)));return u?void 0:{type:e,raw:a[0],attributes:d}}},renderMarkdown:t=>{const e=l(t.attrs||{});const n=o(e);const s=n?` {${n}}`:"";return`:::${c}${s} :::`}}}function Rs(t){const{nodeName:e,name:n,getContent:s,parseAttributes:o=Ns,serializeAttributes:r=Ps,defaultAttributes:i={},content:a="block",allowedAttributes:c}=t;const l=n||e;const d=t=>{if(!c)return t;const e={};c.forEach((n=>{n in t&&(e[n]=t[n])}));return e};return{parseMarkdown:(t,n)=>{let o;if(s){const e=s(t);o=typeof e==="string"?[{type:"text",text:e}]:e}else o=a==="block"?n.parseChildren(t.tokens||[]):n.parseInline(t.tokens||[]);const r={...i,...t.attributes};return n.createNode(e,r,o)},markdownTokenizer:{name:e,level:"block",start(t){var e;const n=new RegExp(`^:::${l}`,"m");const s=(e=t.match(n))==null?void 0:e.index;return s!==void 0?s:-1},tokenize(t,n,s){var r;const i=new RegExp(`^:::${l}(?:\\s+\\{([^}]*)\\})?\\s*\\n`);const c=t.match(i);if(!c)return;const[d,u=""]=c;const p=o(u);let h=1;const m=d.length;let f="";const g=/^:::([\w-]*)(\s.*)?/gm;const v=t.slice(m);g.lastIndex=0;for(;;){const n=g.exec(v);if(n===null)break;const o=n.index;const i=n[1];if(!((r=n[2])==null?void 0:r.endsWith(":::")))if(i)h+=1;else{h-=1;if(h===0){const r=v.slice(0,o);f=r.trim();const i=t.slice(0,m+o+n[0].length);let c=[];if(f)if(a==="block"){c=s.blockTokens(r);c.forEach((t=>{!t.text||t.tokens&&t.tokens.length!==0||(t.tokens=s.inlineTokens(t.text))}));while(c.length>0){const t=c[c.length-1];if(t.type!=="paragraph"||t.text&&t.text.trim()!=="")break;c.pop()}}else c=s.inlineTokens(f);return{type:e,raw:i,attributes:p,content:f,tokens:c}}}}}},renderMarkdown:(t,e)=>{const n=d(t.attrs||{});const s=r(n);const o=s?` {${s}}`:"";const i=e.renderChildren(t.content||[],"\n\n");return`:::${l}${o}\n\n${i}\n\n:::`}}}function Ds(t){if(!t.trim())return{};const e={};const n=/(\w+)=(?:"([^"]*)"|'([^']*)')/g;let s=n.exec(t);while(s!==null){const[,o,r,i]=s;e[o]=r||i;s=n.exec(t)}return e}function js(t){return Object.entries(t).filter((([,t])=>t!==void 0&&t!==null)).map((([t,e])=>`${t}="${e}"`)).join(" ")}function Is(t){const{nodeName:e,name:n,getContent:s,parseAttributes:o=Ds,serializeAttributes:r=js,defaultAttributes:i={},selfClosing:a=false,allowedAttributes:c}=t;const l=n||e;const d=t=>{if(!c)return t;const e={};c.forEach((n=>{const s=typeof n==="string"?n:n.name;const o=typeof n==="string"?void 0:n.skipIfDefault;if(s in t){const n=t[s];if(o!==void 0&&n===o)return;e[s]=n}}));return e};const u=l.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");return{parseMarkdown:(t,n)=>{const o={...i,...t.attributes};if(a)return n.createNode(e,o);const r=s?s(t):t.content||"";return r?n.createNode(e,o,[n.createTextNode(r)]):n.createNode(e,o,[])},markdownTokenizer:{name:e,level:"inline",start(t){const e=a?new RegExp(`\\[${u}\\s*[^\\]]*\\]`):new RegExp(`\\[${u}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${u}\\]`);const n=t.match(e);const s=n==null?void 0:n.index;return s!==void 0?s:-1},tokenize(t,n,s){const r=a?new RegExp(`^\\[${u}\\s*([^\\]]*)\\]`):new RegExp(`^\\[${u}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${u}\\]`);const i=t.match(r);if(!i)return;let c="";let l="";if(a){const[,t]=i;l=t}else{const[,t,e]=i;l=t;c=e||""}const d=o(l.trim());return{type:e,raw:i[0],content:c.trim(),attributes:d}}},renderMarkdown:t=>{let e="";s?e=s(t):t.content&&t.content.length>0&&(e=t.content.filter((t=>t.type==="text")).map((t=>t.text)).join(""));const n=d(t.attrs||{});const o=r(n);const i=o?` ${o}`:"";return a?`[${l}${i}]`:`[${l}${i}]${e}[/${l}]`}}}function Ls(t,e,n){var s,o,r,i;const a=t.split("\n");const c=[];let l="";let d=0;const u=e.baseIndentSize||2;while(d<a.length){const t=a[d];const p=t.match(e.itemPattern);if(!p){if(c.length>0)break;if(t.trim()===""){d+=1;l=`${l}${t}\n`;continue}return}const h=e.extractItemData(p);const{indentLevel:m,mainContent:f}=h;l=`${l}${t}\n`;const g=[f];d+=1;while(d<a.length){const t=a[d];if(t.trim()===""){const e=a.slice(d+1).findIndex((t=>t.trim()!==""));if(e===-1)break;const n=a[d+1+e];const r=((o=(s=n.match(/^(\s*)/))==null?void 0:s[1])==null?void 0:o.length)||0;if(r>m){g.push(t);l=`${l}${t}\n`;d+=1;continue}break}const e=((i=(r=t.match(/^(\s*)/))==null?void 0:r[1])==null?void 0:i.length)||0;if(!(e>m))break;g.push(t);l=`${l}${t}\n`;d+=1}let v;const y=g.slice(1);if(y.length>0){const t=y.map((t=>t.slice(m+u))).join("\n");t.trim()&&(v=e.customNestedParser?e.customNestedParser(t):n.blockTokens(t))}const b=e.createToken(h,v);c.push(b)}if(c.length!==0)return{items:c,raw:l}}function Hs(t,e,n,s){if(!t||!Array.isArray(t.content))return"";const o=typeof n==="function"?n(s):n;const[r,...i]=t.content;const a=e.renderChildren([r]);const c=[`${o}${a}`];i&&i.length>0&&i.forEach((t=>{const n=e.renderChildren([t]);if(n){const t=n.split("\n").map((t=>t?e.indent(t):"")).join("\n");c.push(t)}}));return c.join("\n")}function Bs(t,e,n={}){const{state:s}=e;const{doc:o,tr:r}=s;const i=t;o.descendants(((e,s)=>{const o=r.mapping.map(s);const a=r.mapping.map(s)+e.nodeSize;let c=null;e.marks.forEach((t=>{if(t!==i)return false;c=t}));if(!c)return;let l=false;Object.keys(n).forEach((t=>{n[t]!==c.attrs[t]&&(l=true)}));if(l){const e=t.type.create({...t.attrs,...n});r.removeMark(o,a,t.type);r.addMark(o,a,e)}}));r.docChanged&&e.view.dispatch(r)}var Vs=class{constructor(t,e,n){this.component=t;this.editor=e.editor;this.options={...n};this.mark=e.mark;this.HTMLAttributes=e.HTMLAttributes}get dom(){return this.editor.view.dom}get contentDOM(){return null}
/**
   * Update the attributes of the mark in the document.
   * @param attrs The attributes to update.
   */updateAttributes(t,e){Bs(e||this.mark,this.editor,t)}ignoreMutation(t){if(!this.dom||!this.contentDOM)return true;if(typeof this.options.ignoreMutation==="function")return this.options.ignoreMutation({mutation:t});if(t.type==="selection")return false;if(this.dom.contains(t.target)&&t.type==="childList"&&(xt()||kt())&&this.editor.isFocused){const e=[...Array.from(t.addedNodes),...Array.from(t.removedNodes)];if(e.every((t=>t.isContentEditable)))return false}return this.contentDOM===t.target&&t.type==="attributes"||!this.contentDOM.contains(t.target)}};var _s=class _Node extends Un{constructor(){super(...arguments);this.type="node"}
/**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */static create(t={}){const e=typeof t==="function"?t():t;return new _Node(e)}configure(t){return super.configure(t)}extend(t){const e=typeof t==="function"?t():t;return super.extend(e)}};var Us=class{constructor(t,e,n){this.isDragging=false;this.component=t;this.editor=e.editor;this.options={stopEvent:null,ignoreMutation:null,...n};this.extension=e.extension;this.node=e.node;this.decorations=e.decorations;this.innerDecorations=e.innerDecorations;this.view=e.view;this.HTMLAttributes=e.HTMLAttributes;this.getPos=e.getPos;this.mount()}mount(){}get dom(){return this.editor.view.dom}get contentDOM(){return null}onDragStart(t){var e,n,s,o,r,i,a;const{view:c}=this.editor;const l=t.target;const d=l.nodeType===3?(e=l.parentElement)==null?void 0:e.closest("[data-drag-handle]"):l.closest("[data-drag-handle]");if(!this.dom||((n=this.contentDOM)==null?void 0:n.contains(l))||!d)return;let u=0;let p=0;if(this.dom!==d){const e=this.dom.getBoundingClientRect();const n=d.getBoundingClientRect();const a=(o=t.offsetX)!=null?o:(s=t.nativeEvent)==null?void 0:s.offsetX;const c=(i=t.offsetY)!=null?i:(r=t.nativeEvent)==null?void 0:r.offsetY;u=n.x-e.x+a;p=n.y-e.y+c}const h=this.dom.cloneNode(true);try{const t=this.dom.getBoundingClientRect();h.style.width=`${Math.round(t.width)}px`;h.style.height=`${Math.round(t.height)}px`;h.style.boxSizing="border-box";h.style.pointerEvents="none"}catch{}let m=null;try{m=document.createElement("div");m.style.position="absolute";m.style.top="-9999px";m.style.left="-9999px";m.style.pointerEvents="none";m.appendChild(h);document.body.appendChild(m);(a=t.dataTransfer)==null?void 0:a.setDragImage(h,u,p)}finally{m&&setTimeout((()=>{try{m==null?void 0:m.remove()}catch{}}),0)}const f=this.getPos();if(typeof f!=="number")return;const g=N.create(c.state.doc,f);const v=c.state.tr.setSelection(g);c.dispatch(v)}stopEvent(t){var e;if(!this.dom)return false;if(typeof this.options.stopEvent==="function")return this.options.stopEvent({event:t});const n=t.target;const s=this.dom.contains(n)&&!((e=this.contentDOM)==null?void 0:e.contains(n));if(!s)return false;const o=t.type.startsWith("drag");const r=t.type==="drop";const i=["INPUT","BUTTON","SELECT","TEXTAREA"].includes(n.tagName)||n.isContentEditable;if(i&&!r&&!o)return true;const{isEditable:a}=this.editor;const{isDragging:c}=this;const l=!!this.node.type.spec.draggable;const d=N.isSelectable(this.node);const u=t.type==="copy";const p=t.type==="paste";const h=t.type==="cut";const m=t.type==="mousedown";!l&&d&&o&&t.target===this.dom&&t.preventDefault();if(l&&o&&!c&&t.target===this.dom){t.preventDefault();return false}if(l&&a&&!c&&m){const t=n.closest("[data-drag-handle]");const e=t&&(this.dom===t||this.dom.contains(t));if(e){this.isDragging=true;document.addEventListener("dragend",(()=>{this.isDragging=false}),{once:true});document.addEventListener("drop",(()=>{this.isDragging=false}),{once:true});document.addEventListener("mouseup",(()=>{this.isDragging=false}),{once:true})}}return!(c||r||u||p||h||m&&d)}ignoreMutation(t){if(!this.dom||!this.contentDOM)return true;if(typeof this.options.ignoreMutation==="function")return this.options.ignoreMutation({mutation:t});if(this.node.isLeaf||this.node.isAtom)return true;if(t.type==="selection")return false;if(this.dom.contains(t.target)&&t.type==="childList"&&(xt()||kt())&&this.editor.isFocused){const e=[...Array.from(t.addedNodes),...Array.from(t.removedNodes)];if(e.every((t=>t.isContentEditable)))return false}return this.contentDOM===t.target&&t.type==="attributes"||!this.contentDOM.contains(t.target)}updateAttributes(t){this.editor.commands.command((({tr:e})=>{const n=this.getPos();if(typeof n!=="number")return false;e.setNodeMarkup(n,void 0,{...this.node.attrs,...t});return true}))}deleteNode(){const t=this.getPos();if(typeof t!=="number")return;const e=t+this.node.nodeSize;this.editor.commands.deleteRange({from:t,to:e})}};function Ws(t){return new Kn({find:t.find,handler:({state:e,range:n,match:s,pasteEvent:o})=>{const r=ye(t.getAttributes,void 0,s,o);if(r===false||r===null)return null;const{tr:i}=e;const a=s[s.length-1];const c=s[0];let l=n.to;if(a){const s=c.search(/\S/);const o=n.from+c.indexOf(a);const d=o+a.length;const u=Fe(n.from,n.to,e.doc).filter((e=>{const n=e.mark.type.excluded;return n.find((n=>n===t.type&&n!==e.mark.type))})).filter((t=>t.to>o));if(u.length)return null;d<n.to&&i.delete(d,n.to);o>n.from&&i.delete(n.from+s,o);l=n.from+s+a.length;i.addMark(n.from+s,l,t.type.create(r||{}));i.removeStoredMark(t.type)}}})}function Fs(t){return new Kn({find:t.find,handler({match:e,chain:n,range:s,pasteEvent:o}){const r=ye(t.getAttributes,void 0,e,o);const i=ye(t.getContent,void 0,r);if(r===false||r===null)return null;const a={type:t.type.name,attrs:r};i&&(a.content=i);e.input&&n().deleteRange(s).insertContentAt(s.from,a)}})}function Ks(t){return new Kn({find:t.find,handler:({state:e,range:n,match:s})=>{let o=t.replace;let r=n.from;const i=n.to;if(s[1]){const t=s[0].lastIndexOf(s[1]);o+=s[0].slice(t+s[1].length);r+=t;const e=r-i;if(e>0){o=s[0].slice(t-e,t)+o;r=i}}e.tr.insertText(o,r,i)}})}var qs=class{constructor(t){this.transaction=t;this.currentStep=this.transaction.steps.length}map(t){let e=false;const n=this.transaction.steps.slice(this.currentStep).reduce(((t,n)=>{const s=n.getMap().mapResult(t);s.deleted&&(e=true);return s.pos}),t);return{position:n,deleted:e}}};export{X as CommandManager,fs as Editor,Un as Extendable,ts as Extension,ks as Fragment,jn as InputRule,on as MappablePosition,Wn as Mark,Vs as MarkView,_s as Node,ps as NodePos,Us as NodeView,Kn as PasteRule,Es as ResizableNodeView,Ss as ResizableNodeview,qs as Tracker,ye as callOrReturn,Cs as canInsertNode,ce as combineTransactionSteps,Y as commands,zs as createAtomBlockMarkdownSpec,Rs as createBlockMarkdownSpec,J as createChainableState,re as createDocument,xs as createElement,Is as createInlineMarkdownSpec,an as createMappablePosition,$t as createNodeFromContent,ms as createStyleTag,le as defaultBlockAt,Yt as deleteProps,Ot as elementFromString,Ts as escapeForRegEx,Gn as extensions,de as findChildren,ue as findChildrenInRange,$e as findDuplicates,he as findParentNode,pe as findParentNodeClosestToPos,fe as flattenExtensions,Ee as fromString,ze as generateHTML,Re as generateJSON,Le as generateText,Be as getAttributes,ke as getAttributesFromExtensions,Ue as getChangedRanges,We as getDebugJSON,me as getExtensionField,ge as getHTMLFromFragment,ae as getMarkAttributes,mt as getMarkRange,ft as getMarkType,Fe as getMarksBetween,Ke as getNodeAtPosition,He as getNodeAttributes,ot as getNodeType,Me as getRenderedAttributes,Pe as getSchema,Oe as getSchemaByResolvedExtensions,qe as getSchemaTypeByName,Xt as getSchemaTypeNameByName,Je as getSplittedAttributes,je as getText,De as getTextBetween,Xe as getTextContentFromNodes,Ie as getTextSerializersFromSchema,rn as getUpdatedPosition,xs as h,Se as injectExtensionAttributesToParseRule,Hn as inputRulesPlugin,Ze as isActive,kt as isAndroid,Qe as isAtEndOfNode,Ge as isAtStartOfNode,be as isEmptyObject,tn as isExtensionRulesEnabled,Os as isFirefox,ve as isFunction,en as isList,Vt as isMacOS,Ye as isMarkActive,Wt as isNodeActive,nn as isNodeEmpty,sn as isNodeSelection,Fn as isNumber,Vn as isPlainObject,dt as isRegExp,Mt as isSafari,$s as isString,yt as isTextSelection,xt as isiOS,gs as markInputRule,Ws as markPasteRule,As as markdown,xe as mergeAttributes,_n as mergeDeep,bt as minMax,vs as nodeInputRule,Fs as nodePasteRule,ut as objectIncludes,Ns as parseAttributes,Ls as parseIndentedBlocks,Zn as pasteRulesPlugin,cn as posToDOMRect,Ve as removeDuplicates,Hs as renderNestedMarkdownContent,Ne as resolveExtensions,wt as resolveFocusPosition,dn as rewriteUnknownContent,At as selectionToInsertionEnd,Ps as serializeAttributes,Ae as sortExtensions,we as splitExtensions,bs as textInputRule,Ks as textPasteRule,ys as textblockTypeInputRule,Bs as updateMarkViewAttributes,ws as wrappingInputRule};


// prosemirror-schema-list@1.5.1 downloaded from https://ga.jspm.io/npm:prosemirror-schema-list@1.5.1/dist/index.js

import{findWrapping as e,ReplaceAroundStep as t,canSplit as r,liftTarget as n,canJoin as o}from"prosemirror-transform";import{NodeRange as l,Fragment as i,Slice as d}from"prosemirror-model";import{Selection as s}from"prosemirror-state";const f=["ol",0],p=["ul",0],u=["li",0];const a={attrs:{order:{default:1,validate:"number"}},parseDOM:[{tag:"ol",getAttrs(e){return{order:e.hasAttribute("start")?+e.getAttribute("start"):1}}}],toDOM(e){return e.attrs.order==1?f:["ol",{start:e.attrs.order},0]}};const c={parseDOM:[{tag:"ul"}],toDOM(){return p}};const m={parseDOM:[{tag:"li"}],toDOM(){return u},defining:true};function h(e,t){let r={};for(let t in e)r[t]=e[t];for(let e in t)r[e]=t[e];return r}function y(e,t,r){return e.append({ordered_list:h(a,{content:"list_item+",group:r}),bullet_list:h(c,{content:"list_item+",group:r}),list_item:h(m,{content:t})})}function w(e,t=null){return function(r,n){let{$from:o,$to:l}=r.selection;let i=o.blockRange(l);if(!i)return false;let d=n?r.tr:null;if(!x(d,i,e,t))return false;n&&n(d.scrollIntoView());return true}}function x(t,r,n,o=null){let i=false,d=r,s=r.$from.doc;if(r.depth>=2&&r.$from.node(r.depth-1).type.compatibleContent(n)&&r.startIndex==0){if(r.$from.index(r.depth-1)==0)return false;let e=s.resolve(r.start-2);d=new l(e,e,r.depth);r.endIndex<r.parent.childCount&&(r=new l(r.$from,s.resolve(r.$to.end(r.depth)),r.depth));i=true}let f=e(d,n,o,r);if(!f)return false;t&&g(t,r,f,i,n);return true}function g(e,n,o,l,s){let f=i.empty;for(let e=o.length-1;e>=0;e--)f=i.from(o[e].type.create(o[e].attrs,f));e.step(new t(n.start-(l?2:0),n.end,n.start,n.end,new d(f,0,0),o.length,true));let p=0;for(let e=0;e<o.length;e++)o[e].type==s&&(p=e+1);let u=o.length-p;let a=n.start+o.length-(l?2:0),c=n.parent;for(let t=n.startIndex,o=n.endIndex,l=true;t<o;t++,l=false){if(!l&&r(e.doc,a,u)){e.split(a,u);a+=2*u}a+=c.child(t).nodeSize}return e}function $(e,t){return function(n,o){let{$from:l,$to:f,node:p}=n.selection;if(p&&p.isBlock||l.depth<2||!l.sameParent(f))return false;let u=l.node(-1);if(u.type!=e)return false;if(l.parent.content.size==0&&l.node(-1).childCount==l.indexAfter(-1)){if(l.depth==3||l.node(-3).type!=e||l.index(-2)!=l.node(-2).childCount-1)return false;if(o){let t=i.empty;let r=l.index(-1)?1:l.index(-2)?2:3;for(let e=l.depth-r;e>=l.depth-3;e--)t=i.from(l.node(e).copy(t));let f=l.indexAfter(-1)<l.node(-2).childCount?1:l.indexAfter(-2)<l.node(-3).childCount?2:3;t=t.append(i.from(e.createAndFill()));let p=l.before(l.depth-(r-1));let u=n.tr.replace(p,l.after(-f),new d(t,4-r,0));let a=-1;u.doc.nodesBetween(p,u.doc.content.size,((e,t)=>{if(a>-1)return false;e.isTextblock&&e.content.size==0&&(a=t+1)}));a>-1&&u.setSelection(s.near(u.doc.resolve(a)));o(u.scrollIntoView())}return true}let a=f.pos==l.end()?u.contentMatchAt(0).defaultType:null;let c=n.tr.delete(l.pos,f.pos);let m=a?[t?{type:e,attrs:t}:null,{type:a}]:void 0;if(!r(c.doc,l.pos,2,m))return false;o&&o(c.split(l.pos,2,m).scrollIntoView());return true}}function I(e,t){let r=$(e,t);return(e,t)=>r(e,t&&(r=>{let n=e.storedMarks||e.selection.$to.parentOffset&&e.selection.$from.marks();n&&r.ensureMarks(n);t(r)}))}function C(e){return function(t,r){let{$from:n,$to:o}=t.selection;let l=n.blockRange(o,(t=>t.childCount>0&&t.firstChild.type==e));return!!l&&(!r||(n.node(l.depth-1).type==e?A(t,r,e,l):b(t,r,l)))}}function A(e,r,s,f){let p=e.tr,u=f.end,a=f.$to.end(f.depth);if(u<a){p.step(new t(u-1,a,u,a,new d(i.from(s.create(null,f.parent.copy())),1,0),1,true));f=new l(p.doc.resolve(f.$from.pos),p.doc.resolve(a),f.depth)}const c=n(f);if(c==null)return false;p.lift(f,c);let m=p.doc.resolve(p.mapping.map(u,-1)-1);o(p.doc,m.pos)&&m.nodeBefore.type==m.nodeAfter.type&&p.join(m.pos);r(p.scrollIntoView());return true}function b(e,r,n){let o=e.tr,l=n.parent;for(let e=n.end,t=n.endIndex-1,r=n.startIndex;t>r;t--){e-=l.child(t).nodeSize;o.delete(e-1,e+1)}let s=o.doc.resolve(n.start),f=s.nodeAfter;if(o.mapping.map(n.end)!=n.start+s.nodeAfter.nodeSize)return false;let p=n.startIndex==0,u=n.endIndex==l.childCount;let a=s.node(-1),c=s.index(-1);if(!a.canReplace(c+(p?0:1),c+1,f.content.append(u?i.empty:i.from(l))))return false;let m=s.pos,h=m+f.nodeSize;o.step(new t(m-(p?1:0),h+(u?1:0),m+1,h-1,new d((p?i.empty:i.from(l.copy(i.empty))).append(u?i.empty:i.from(l.copy(i.empty))),p?0:1,u?0:1),p?0:1));r(o.scrollIntoView());return true}function v(e){return function(r,n){let{$from:o,$to:l}=r.selection;let s=o.blockRange(l,(t=>t.childCount>0&&t.firstChild.type==e));if(!s)return false;let f=s.startIndex;if(f==0)return false;let p=s.parent,u=p.child(f-1);if(u.type!=e)return false;if(n){let o=u.lastChild&&u.lastChild.type==p.type;let l=i.from(o?e.create():null);let f=new d(i.from(e.create(null,i.from(p.type.create(null,l)))),o?3:1,0);let a=s.start,c=s.end;n(r.tr.step(new t(a-(o?3:1),c,a,c,f,1,true)).scrollIntoView())}return true}}export{y as addListNodes,c as bulletList,C as liftListItem,m as listItem,a as orderedList,v as sinkListItem,$ as splitListItem,I as splitListItemKeepMarks,w as wrapInList,x as wrapRangeInList};


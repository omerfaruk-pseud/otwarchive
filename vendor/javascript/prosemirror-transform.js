// prosemirror-transform@1.11.0 downloaded from https://ga.jspm.io/npm:prosemirror-transform@1.11.0/dist/index.js

import{ReplaceError as e,Fragment as t,Slice as r,MarkType as n,Mark as i}from"prosemirror-model";const s=65535;const o=Math.pow(2,16);function l(e,t){return e+t*o}function p(e){return e&s}function a(e){return(e-(e&s))/o}const h=1,c=2,d=4,f=8;class MapResult{constructor(e,t,r){this.pos=e;this.delInfo=t;this.recover=r}get deleted(){return(this.delInfo&f)>0}get deletedBefore(){return(this.delInfo&(h|d))>0}get deletedAfter(){return(this.delInfo&(c|d))>0}get deletedAcross(){return(this.delInfo&d)>0}}class StepMap{constructor(e,t=false){this.ranges=e;this.inverted=t;if(!e.length&&StepMap.empty)return StepMap.empty}recover(e){let t=0,r=p(e);if(!this.inverted)for(let e=0;e<r;e++)t+=this.ranges[e*3+2]-this.ranges[e*3+1];return this.ranges[r*3]+t+a(e)}mapResult(e,t=1){return this._map(e,t,false)}map(e,t=1){return this._map(e,t,true)}_map(e,t,r){let n=0,i=this.inverted?2:1,s=this.inverted?1:2;for(let o=0;o<this.ranges.length;o+=3){let p=this.ranges[o]-(this.inverted?n:0);if(p>e)break;let a=this.ranges[o+i],u=this.ranges[o+s],m=p+a;if(e<=m){let i=a?e==p?-1:e==m?1:t:t;let s=p+n+(i<0?0:u);if(r)return s;let S=e==(t<0?p:m)?null:l(o/3,e-p);let g=e==p?c:e==m?h:d;(t<0?e!=p:e!=m)&&(g|=f);return new MapResult(s,g,S)}n+=u-a}return r?e+n:new MapResult(e+n,0,null)}touches(e,t){let r=0,n=p(t);let i=this.inverted?2:1,s=this.inverted?1:2;for(let t=0;t<this.ranges.length;t+=3){let o=this.ranges[t]-(this.inverted?r:0);if(o>e)break;let l=this.ranges[t+i],p=o+l;if(e<=p&&t==n*3)return true;r+=this.ranges[t+s]-l}return false}forEach(e){let t=this.inverted?2:1,r=this.inverted?1:2;for(let n=0,i=0;n<this.ranges.length;n+=3){let s=this.ranges[n],o=s-(this.inverted?i:0),l=s+(this.inverted?0:i);let p=this.ranges[n+t],a=this.ranges[n+r];e(o,o+p,l,l+a);i+=a-p}}invert(){return new StepMap(this.ranges,!this.inverted)}toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}static offset(e){return e==0?StepMap.empty:new StepMap(e<0?[0,-e,0]:[0,0,e])}}StepMap.empty=new StepMap([]);class Mapping{constructor(e,t,r=0,n=(e?e.length:0)){this.mirror=t;this.from=r;this.to=n;this._maps=e||[];this.ownData=!(e||t)}get maps(){return this._maps}slice(e=0,t=this.maps.length){return new Mapping(this._maps,this.mirror,e,t)}appendMap(e,t){if(!this.ownData){this._maps=this._maps.slice();this.mirror=this.mirror&&this.mirror.slice();this.ownData=true}this.to=this._maps.push(e);t!=null&&this.setMirror(this._maps.length-1,t)}appendMapping(e){for(let t=0,r=this._maps.length;t<e._maps.length;t++){let n=e.getMirror(t);this.appendMap(e._maps[t],n!=null&&n<t?r+n:void 0)}}getMirror(e){if(this.mirror)for(let t=0;t<this.mirror.length;t++)if(this.mirror[t]==e)return this.mirror[t+(t%2?-1:1)]}setMirror(e,t){this.mirror||(this.mirror=[]);this.mirror.push(e,t)}appendMappingInverted(e){for(let t=e.maps.length-1,r=this._maps.length+e._maps.length;t>=0;t--){let n=e.getMirror(t);this.appendMap(e._maps[t].invert(),n!=null&&n>t?r-n-1:void 0)}}invert(){let e=new Mapping;e.appendMappingInverted(this);return e}map(e,t=1){if(this.mirror)return this._map(e,t,true);for(let r=this.from;r<this.to;r++)e=this._maps[r].map(e,t);return e}mapResult(e,t=1){return this._map(e,t,false)}_map(e,t,r){let n=0;for(let r=this.from;r<this.to;r++){let i=this._maps[r],s=i.mapResult(e,t);if(s.recover!=null){let t=this.getMirror(r);if(t!=null&&t>r&&t<this.to){r=t;e=this._maps[t].recover(s.recover);continue}}n|=s.delInfo;e=s.pos}return r?e:new MapResult(e,n,null)}}const u=Object.create(null);class Step{getMap(){return StepMap.empty}merge(e){return null}static fromJSON(e,t){if(!t||!t.stepType)throw new RangeError("Invalid input for Step.fromJSON");let r=u[t.stepType];if(!r)throw new RangeError(`No step type ${t.stepType} defined`);return r.fromJSON(e,t)}static jsonID(e,t){if(e in u)throw new RangeError("Duplicate use of step JSON ID "+e);u[e]=t;t.prototype.jsonID=e;return t}}class StepResult{constructor(e,t){this.doc=e;this.failed=t}static ok(e){return new StepResult(e,null)}static fail(e){return new StepResult(null,e)}static fromReplace(t,r,n,i){try{return StepResult.ok(t.replace(r,n,i))}catch(t){if(t instanceof e)return StepResult.fail(t.message);throw t}}}function m(e,r,n){let i=[];for(let t=0;t<e.childCount;t++){let s=e.child(t);s.content.size&&(s=s.copy(m(s.content,r,s)));s.isInline&&(s=r(s,n,t));i.push(s)}return t.fromArray(i)}class AddMarkStep extends Step{constructor(e,t,r){super();this.from=e;this.to=t;this.mark=r}apply(e){let t=e.slice(this.from,this.to),n=e.resolve(this.from);let i=n.node(n.sharedDepth(this.to));let s=new r(m(t.content,((e,t)=>e.isAtom&&t.type.allowsMarkType(this.mark.type)?e.mark(this.mark.addToSet(e.marks)):e),i),t.openStart,t.openEnd);return StepResult.fromReplace(e,this.from,this.to,s)}invert(){return new RemoveMarkStep(this.from,this.to,this.mark)}map(e){let t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);return t.deleted&&r.deleted||t.pos>=r.pos?null:new AddMarkStep(t.pos,r.pos,this.mark)}merge(e){return e instanceof AddMarkStep&&e.mark.eq(this.mark)&&this.from<=e.to&&this.to>=e.from?new AddMarkStep(Math.min(this.from,e.from),Math.max(this.to,e.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}static fromJSON(e,t){if(typeof t.from!="number"||typeof t.to!="number")throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new AddMarkStep(t.from,t.to,e.markFromJSON(t.mark))}}Step.jsonID("addMark",AddMarkStep);class RemoveMarkStep extends Step{constructor(e,t,r){super();this.from=e;this.to=t;this.mark=r}apply(e){let t=e.slice(this.from,this.to);let n=new r(m(t.content,(e=>e.mark(this.mark.removeFromSet(e.marks))),e),t.openStart,t.openEnd);return StepResult.fromReplace(e,this.from,this.to,n)}invert(){return new AddMarkStep(this.from,this.to,this.mark)}map(e){let t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);return t.deleted&&r.deleted||t.pos>=r.pos?null:new RemoveMarkStep(t.pos,r.pos,this.mark)}merge(e){return e instanceof RemoveMarkStep&&e.mark.eq(this.mark)&&this.from<=e.to&&this.to>=e.from?new RemoveMarkStep(Math.min(this.from,e.from),Math.max(this.to,e.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}static fromJSON(e,t){if(typeof t.from!="number"||typeof t.to!="number")throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new RemoveMarkStep(t.from,t.to,e.markFromJSON(t.mark))}}Step.jsonID("removeMark",RemoveMarkStep);class AddNodeMarkStep extends Step{constructor(e,t){super();this.pos=e;this.mark=t}apply(e){let n=e.nodeAt(this.pos);if(!n)return StepResult.fail("No node at mark step's position");let i=n.type.create(n.attrs,null,this.mark.addToSet(n.marks));return StepResult.fromReplace(e,this.pos,this.pos+1,new r(t.from(i),0,n.isLeaf?0:1))}invert(e){let t=e.nodeAt(this.pos);if(t){let e=this.mark.addToSet(t.marks);if(e.length==t.marks.length){for(let r=0;r<t.marks.length;r++)if(!t.marks[r].isInSet(e))return new AddNodeMarkStep(this.pos,t.marks[r]);return new AddNodeMarkStep(this.pos,this.mark)}}return new RemoveNodeMarkStep(this.pos,this.mark)}map(e){let t=e.mapResult(this.pos,1);return t.deletedAfter?null:new AddNodeMarkStep(t.pos,this.mark)}toJSON(){return{stepType:"addNodeMark",pos:this.pos,mark:this.mark.toJSON()}}static fromJSON(e,t){if(typeof t.pos!="number")throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");return new AddNodeMarkStep(t.pos,e.markFromJSON(t.mark))}}Step.jsonID("addNodeMark",AddNodeMarkStep);class RemoveNodeMarkStep extends Step{constructor(e,t){super();this.pos=e;this.mark=t}apply(e){let n=e.nodeAt(this.pos);if(!n)return StepResult.fail("No node at mark step's position");let i=n.type.create(n.attrs,null,this.mark.removeFromSet(n.marks));return StepResult.fromReplace(e,this.pos,this.pos+1,new r(t.from(i),0,n.isLeaf?0:1))}invert(e){let t=e.nodeAt(this.pos);return t&&this.mark.isInSet(t.marks)?new AddNodeMarkStep(this.pos,this.mark):this}map(e){let t=e.mapResult(this.pos,1);return t.deletedAfter?null:new RemoveNodeMarkStep(t.pos,this.mark)}toJSON(){return{stepType:"removeNodeMark",pos:this.pos,mark:this.mark.toJSON()}}static fromJSON(e,t){if(typeof t.pos!="number")throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");return new RemoveNodeMarkStep(t.pos,e.markFromJSON(t.mark))}}Step.jsonID("removeNodeMark",RemoveNodeMarkStep);class ReplaceStep extends Step{constructor(e,t,r,n=false){super();this.from=e;this.to=t;this.slice=r;this.structure=n}apply(e){return this.structure&&S(e,this.from,this.to)?StepResult.fail("Structure replace would overwrite content"):StepResult.fromReplace(e,this.from,this.to,this.slice)}getMap(){return new StepMap([this.from,this.to-this.from,this.slice.size])}invert(e){return new ReplaceStep(this.from,this.from+this.slice.size,e.slice(this.from,this.to))}map(e){let t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);return t.deletedAcross&&r.deletedAcross?null:new ReplaceStep(t.pos,Math.max(t.pos,r.pos),this.slice,this.structure)}merge(e){if(!(e instanceof ReplaceStep)||e.structure||this.structure)return null;if(this.from+this.slice.size!=e.from||this.slice.openEnd||e.slice.openStart){if(e.to!=this.from||this.slice.openStart||e.slice.openEnd)return null;{let t=this.slice.size+e.slice.size==0?r.empty:new r(e.slice.content.append(this.slice.content),e.slice.openStart,this.slice.openEnd);return new ReplaceStep(e.from,this.to,t,this.structure)}}{let t=this.slice.size+e.slice.size==0?r.empty:new r(this.slice.content.append(e.slice.content),this.slice.openStart,e.slice.openEnd);return new ReplaceStep(this.from,this.to+(e.to-e.from),t,this.structure)}}toJSON(){let e={stepType:"replace",from:this.from,to:this.to};this.slice.size&&(e.slice=this.slice.toJSON());this.structure&&(e.structure=true);return e}static fromJSON(e,t){if(typeof t.from!="number"||typeof t.to!="number")throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new ReplaceStep(t.from,t.to,r.fromJSON(e,t.slice),!!t.structure)}}Step.jsonID("replace",ReplaceStep);class ReplaceAroundStep extends Step{constructor(e,t,r,n,i,s,o=false){super();this.from=e;this.to=t;this.gapFrom=r;this.gapTo=n;this.slice=i;this.insert=s;this.structure=o}apply(e){if(this.structure&&(S(e,this.from,this.gapFrom)||S(e,this.gapTo,this.to)))return StepResult.fail("Structure gap-replace would overwrite content");let t=e.slice(this.gapFrom,this.gapTo);if(t.openStart||t.openEnd)return StepResult.fail("Gap is not a flat range");let r=this.slice.insertAt(this.insert,t.content);return r?StepResult.fromReplace(e,this.from,this.to,r):StepResult.fail("Content does not fit in gap")}getMap(){return new StepMap([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(e){let t=this.gapTo-this.gapFrom;return new ReplaceAroundStep(this.from,this.from+this.slice.size+t,this.from+this.insert,this.from+this.insert+t,e.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(e){let t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);let n=this.from==this.gapFrom?t.pos:e.map(this.gapFrom,-1);let i=this.to==this.gapTo?r.pos:e.map(this.gapTo,1);return t.deletedAcross&&r.deletedAcross||n<t.pos||i>r.pos?null:new ReplaceAroundStep(t.pos,r.pos,n,i,this.slice,this.insert,this.structure)}toJSON(){let e={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};this.slice.size&&(e.slice=this.slice.toJSON());this.structure&&(e.structure=true);return e}static fromJSON(e,t){if(typeof t.from!="number"||typeof t.to!="number"||typeof t.gapFrom!="number"||typeof t.gapTo!="number"||typeof t.insert!="number")throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new ReplaceAroundStep(t.from,t.to,t.gapFrom,t.gapTo,r.fromJSON(e,t.slice),t.insert,!!t.structure)}}Step.jsonID("replaceAround",ReplaceAroundStep);function S(e,t,r){let n=e.resolve(t),i=r-t,s=n.depth;while(i>0&&s>0&&n.indexAfter(s)==n.node(s).childCount){s--;i--}if(i>0){let e=n.node(s).maybeChild(n.indexAfter(s));while(i>0){if(!e||e.isLeaf)return true;e=e.firstChild;i--}}return false}function g(e,t,r,n){let i=[],s=[];let o,l;e.doc.nodesBetween(t,r,((e,p,a)=>{if(!e.isInline)return;let h=e.marks;if(!n.isInSet(h)&&a.type.allowsMarkType(n.type)){let a=Math.max(p,t),c=Math.min(p+e.nodeSize,r);let d=n.addToSet(h);for(let e=0;e<h.length;e++)h[e].isInSet(d)||(o&&o.to==a&&o.mark.eq(h[e])?o.to=c:i.push(o=new RemoveMarkStep(a,c,h[e])));l&&l.to==a?l.to=c:s.push(l=new AddMarkStep(a,c,n))}}));i.forEach((t=>e.step(t)));s.forEach((t=>e.step(t)))}function y(e,t,r,i){let s=[],o=0;e.doc.nodesBetween(t,r,((e,l)=>{if(!e.isInline)return;o++;let p=null;if(i instanceof n){let t,r=e.marks;while(t=i.isInSet(r)){(p||(p=[])).push(t);r=t.removeFromSet(r)}}else i?i.isInSet(e.marks)&&(p=[i]):p=e.marks;if(p&&p.length){let n=Math.min(l+e.nodeSize,r);for(let e=0;e<p.length;e++){let r,i=p[e];for(let e=0;e<s.length;e++){let t=s[e];t.step==o-1&&i.eq(s[e].style)&&(r=t)}if(r){r.to=n;r.step=o}else s.push({style:i,from:Math.max(l,t),to:n,step:o})}}}));s.forEach((t=>e.step(new RemoveMarkStep(t.from,t.to,t.style))))}function k(e,n,i,s=i.contentMatch,o=true){let l=e.doc.nodeAt(n);let p=[],a=n+1;for(let n=0;n<l.childCount;n++){let h=l.child(n),c=a+h.nodeSize;let d=s.matchType(h.type);if(d){s=d;for(let t=0;t<h.marks.length;t++)i.allowsMarkType(h.marks[t].type)||e.step(new RemoveMarkStep(a,c,h.marks[t]));if(o&&h.isText&&i.whitespace!="pre"){let e,n,s=/\r?\n|\r/g;while(e=s.exec(h.text)){n||(n=new r(t.from(i.schema.text(" ",i.allowedMarks(h.marks))),0,0));p.push(new ReplaceStep(a+e.index,a+e.index+e[0].length,n))}}}else p.push(new ReplaceStep(a,c,r.empty));a=c}if(!s.validEnd){let n=s.fillBefore(t.empty,true);e.replace(a,a,new r(n,0,0))}for(let t=p.length-1;t>=0;t--)e.step(p[t])}function w(e,t,r){return(t==0||e.canReplace(t,e.childCount))&&(r==e.childCount||e.canReplace(0,r))}function R(e){let t=e.parent;let r=t.content.cutByIndex(e.startIndex,e.endIndex);for(let t=e.depth,n=0,i=0;;--t){let s=e.$from.node(t);let o=e.$from.index(t)+n,l=e.$to.indexAfter(t)-i;if(t<e.depth&&s.canReplace(o,l,r))return t;if(t==0||s.type.spec.isolating||!w(s,o,l))break;o&&(n=1);l<s.childCount&&(i=1)}return null}function M(e,n,i){let{$from:s,$to:o,depth:l}=n;let p=s.before(l+1),a=o.after(l+1);let h=p,c=a;let d=t.empty,f=0;for(let e=l,r=false;e>i;e--)if(r||s.index(e)>0){r=true;d=t.from(s.node(e).copy(d));f++}else h--;let u=t.empty,m=0;for(let e=l,r=false;e>i;e--)if(r||o.after(e+1)<o.end(e)){r=true;u=t.from(o.node(e).copy(u));m++}else c++;e.step(new ReplaceAroundStep(h,c,p,a,new r(d.append(u),f,m),d.size-f,true))}function v(e,t,r=null,n=e){let i=N(e,t);let s=i&&x(n,t);return s?i.map(A).concat({type:t,attrs:r}).concat(s.map(A)):null}function A(e){return{type:e,attrs:null}}function N(e,t){let{parent:r,startIndex:n,endIndex:i}=e;let s=r.contentMatchAt(n).findWrapping(t);if(!s)return null;let o=s.length?s[0]:t;return r.canReplaceWith(n,i,o)?s:null}function x(e,t){let{parent:r,startIndex:n,endIndex:i}=e;let s=r.child(n);let o=t.contentMatch.findWrapping(s.type);if(!o)return null;let l=o.length?o[o.length-1]:t;let p=l.contentMatch;for(let e=n;p&&e<i;e++)p=p.matchType(r.child(e).type);return p&&p.validEnd?o:null}function C(e,n,i){let s=t.empty;for(let e=i.length-1;e>=0;e--){if(s.size){let t=i[e].type.contentMatch.matchFragment(s);if(!t||!t.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}s=t.from(i[e].type.create(i[e].attrs,s))}let o=n.start,l=n.end;e.step(new ReplaceAroundStep(o,l,o,l,new r(s,0,0),i.length,true))}function b(e,n,i,s,o){if(!s.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let l=e.steps.length;e.doc.nodesBetween(n,i,((n,i)=>{let p=typeof o=="function"?o(n):o;if(n.isTextblock&&!n.hasMarkup(s,p)&&O(e.doc,e.mapping.slice(l).map(i),s)){let o=null;if(s.schema.linebreakReplacement){let e=s.whitespace=="pre",t=!!s.contentMatch.matchType(s.schema.linebreakReplacement);e&&!t?o=false:!e&&t&&(o=true)}o===false&&I(e,n,i,l);k(e,e.mapping.slice(l).map(i,1),s,void 0,o===null);let a=e.mapping.slice(l);let h=a.map(i,1),c=a.map(i+n.nodeSize,1);e.step(new ReplaceAroundStep(h,c,h+1,c-1,new r(t.from(s.create(p,null,n.marks)),0,0),1,true));o===true&&T(e,n,i,l);return false}}))}function T(e,t,r,n){t.forEach(((i,s)=>{if(i.isText){let o,l=/\r?\n|\r/g;while(o=l.exec(i.text)){let i=e.mapping.slice(n).map(r+1+s+o.index);e.replaceWith(i,i+1,t.type.schema.linebreakReplacement.create())}}}))}function I(e,t,r,n){t.forEach(((i,s)=>{if(i.type==i.type.schema.linebreakReplacement){let i=e.mapping.slice(n).map(r+1+s);e.replaceWith(i,i+1,t.type.schema.text("\n"))}}))}function O(e,t,r){let n=e.resolve(t),i=n.index();return n.parent.canReplaceWith(i,i+1,r)}function E(e,n,i,s,o){let l=e.doc.nodeAt(n);if(!l)throw new RangeError("No node at given position");i||(i=l.type);let p=i.create(s,null,o||l.marks);if(l.isLeaf)return e.replaceWith(n,n+l.nodeSize,p);if(!i.validContent(l.content))throw new RangeError("Invalid content for node type "+i.name);e.step(new ReplaceAroundStep(n,n+l.nodeSize,n+1,n+l.nodeSize-1,new r(t.from(p),0,0),1,true))}function J(e,t,r=1,n){let i=e.resolve(t),s=i.depth-r;let o=n&&n[n.length-1]||i.parent;if(s<0||i.parent.type.spec.isolating||!i.parent.canReplace(i.index(),i.parent.childCount)||!o.type.validContent(i.parent.content.cutByIndex(i.index(),i.parent.childCount)))return false;for(let e=i.depth-1,t=r-2;e>s;e--,t--){let r=i.node(e),s=i.index(e);if(r.type.spec.isolating)return false;let o=r.content.cutByIndex(s,r.childCount);let l=n&&n[t+1];l&&(o=o.replaceChild(0,l.type.create(l.attrs)));let p=n&&n[t]||r;if(!r.canReplace(s+1,r.childCount)||!p.type.validContent(o))return false}let l=i.indexAfter(s);let p=n&&n[0];return i.node(s).canReplaceWith(l,l,p?p.type:i.node(s+1).type)}function z(e,n,i=1,s){let o=e.doc.resolve(n),l=t.empty,p=t.empty;for(let e=o.depth,r=o.depth-i,n=i-1;e>r;e--,n--){l=t.from(o.node(e).copy(l));let r=s&&s[n];p=t.from(r?r.type.create(r.attrs,p):o.node(e).copy(p))}e.step(new ReplaceStep(n,n,new r(l.append(p),i,i),true))}function F(e,t){let r=e.resolve(t),n=r.index();return _(r.nodeBefore,r.nodeAfter)&&r.parent.canReplace(n,n+1)}function D(e,t){t.content.size||e.type.compatibleContent(t.type);let r=e.contentMatchAt(e.childCount);let{linebreakReplacement:n}=e.type.schema;for(let i=0;i<t.childCount;i++){let s=t.child(i);let o=s.type==n?e.type.schema.nodes.text:s.type;r=r.matchType(o);if(!r)return false;if(!e.type.allowsMarks(s.marks))return false}return r.validEnd}function _(e,t){return!!(e&&t&&!e.isLeaf&&D(e,t))}function B(e,t,r=-1){let n=e.resolve(t);for(let e=n.depth;;e--){let i,s,o=n.index(e);if(e==n.depth){i=n.nodeBefore;s=n.nodeAfter}else if(r>0){i=n.node(e+1);o++;s=n.node(e).maybeChild(o)}else{i=n.node(e).maybeChild(o-1);s=n.node(e+1)}if(i&&!i.isTextblock&&_(i,s)&&n.node(e).canReplace(o,o+1))return t;if(e==0)break;t=r<0?n.before(e):n.after(e)}}function $(e,t,n){let i=null;let{linebreakReplacement:s}=e.doc.type.schema;let o=e.doc.resolve(t-n),l=o.node().type;if(s&&l.inlineContent){let e=l.whitespace=="pre";let t=!!l.contentMatch.matchType(s);e&&!t?i=false:!e&&t&&(i=true)}let p=e.steps.length;if(i===false){let r=e.doc.resolve(t+n);I(e,r.node(),r.before(),p)}l.inlineContent&&k(e,t+n-1,l,o.node().contentMatchAt(o.index()),i==null);let a=e.mapping.slice(p),h=a.map(t-n);e.step(new ReplaceStep(h,a.map(t+n,-1),r.empty,true));if(i===true){let t=e.doc.resolve(h);T(e,t.node(),t.before(),e.steps.length)}return e}function W(e,t,r){let n=e.resolve(t);if(n.parent.canReplaceWith(n.index(),n.index(),r))return t;if(n.parentOffset==0)for(let e=n.depth-1;e>=0;e--){let t=n.index(e);if(n.node(e).canReplaceWith(t,t,r))return n.before(e+1);if(t>0)return null}if(n.parentOffset==n.parent.content.size)for(let e=n.depth-1;e>=0;e--){let t=n.indexAfter(e);if(n.node(e).canReplaceWith(t,t,r))return n.after(e+1);if(t<n.node(e).childCount)return null}return null}function j(e,t,r){let n=e.resolve(t);if(!r.content.size)return t;let i=r.content;for(let e=0;e<r.openStart;e++)i=i.firstChild.content;for(let e=1;e<=(r.openStart==0&&r.size?2:1);e++)for(let t=n.depth;t>=0;t--){let r=t==n.depth?0:n.pos<=(n.start(t+1)+n.end(t+1))/2?-1:1;let s=n.index(t)+(r>0?1:0);let o=n.node(t),l=false;if(e==1)l=o.canReplace(s,s,i);else{let e=o.contentMatchAt(s).findWrapping(i.firstChild.type);l=e&&o.canReplaceWith(s,s,e[0])}if(l)return r==0?n.pos:r<0?n.before(t+1):n.after(t+1)}return null}function L(e,t,n=t,i=r.empty){if(t==n&&!i.size)return null;let s=e.resolve(t),o=e.resolve(n);return q(s,o,i)?new ReplaceStep(t,n,i):new Fitter(s,o,i).fit()}function q(e,t,r){return!r.openStart&&!r.openEnd&&e.start()==t.start()&&e.parent.canReplace(e.index(),t.index(),r.content)}class Fitter{constructor(e,r,n){this.$from=e;this.$to=r;this.unplaced=n;this.frontier=[];this.placed=t.empty;for(let t=0;t<=e.depth;t++){let r=e.node(t);this.frontier.push({type:r.type,match:r.contentMatchAt(e.indexAfter(t))})}for(let r=e.depth;r>0;r--)this.placed=t.from(e.node(r).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){while(this.unplaced.size){let e=this.findFittable();e?this.placeNodes(e):this.openMore()||this.dropNode()}let e=this.mustMoveInline(),t=this.placed.size-this.depth-this.$from.depth;let n=this.$from,i=this.close(e<0?this.$to:n.doc.resolve(e));if(!i)return null;let s=this.placed,o=n.depth,l=i.depth;while(o&&l&&s.childCount==1){s=s.firstChild.content;o--;l--}let p=new r(s,o,l);return e>-1?new ReplaceAroundStep(n.pos,e,this.$to.pos,this.$to.end(),p,t):p.size||n.pos!=this.$to.pos?new ReplaceStep(n.pos,i.pos,p):null}findFittable(){let e=this.unplaced.openStart;for(let t=this.unplaced.content,r=0,n=this.unplaced.openEnd;r<e;r++){let i=t.firstChild;t.childCount>1&&(n=0);if(i.type.spec.isolating&&n<=r){e=r;break}t=i.content}for(let r=1;r<=2;r++)for(let n=r==1?e:this.unplaced.openStart;n>=0;n--){let e,i=null;if(n){i=K(this.unplaced.content,n-1).firstChild;e=i.content}else e=this.unplaced.content;let s=e.firstChild;for(let e=this.depth;e>=0;e--){let o,{type:l,match:p}=this.frontier[e],a=null;if(r==1&&(s?p.matchType(s.type)||(a=p.fillBefore(t.from(s),false)):i&&l.compatibleContent(i.type)))return{sliceDepth:n,frontierDepth:e,parent:i,inject:a};if(r==2&&s&&(o=p.findWrapping(s.type)))return{sliceDepth:n,frontierDepth:e,parent:i,wrap:o};if(i&&p.matchType(i.type))break}}}openMore(){let{content:e,openStart:t,openEnd:n}=this.unplaced;let i=K(e,t);if(!i.childCount||i.firstChild.isLeaf)return false;this.unplaced=new r(e,t+1,Math.max(n,i.size+t>=e.size-n?t+1:0));return true}dropNode(){let{content:e,openStart:t,openEnd:n}=this.unplaced;let i=K(e,t);if(i.childCount<=1&&t>0){let s=e.size-t<=t+i.size;this.unplaced=new r(G(e,t-1,1),t-1,s?t-1:n)}else this.unplaced=new r(G(e,t,1),t,n)}placeNodes({sliceDepth:e,frontierDepth:n,parent:i,inject:s,wrap:o}){while(this.depth>n)this.closeFrontierNode();if(o)for(let e=0;e<o.length;e++)this.openFrontierNode(o[e]);let l=this.unplaced,p=i?i.content:l.content;let a=l.openStart-e;let h=0,c=[];let{match:d,type:f}=this.frontier[n];if(s){for(let e=0;e<s.childCount;e++)c.push(s.child(e));d=d.matchFragment(s)}let u=p.size+e-(l.content.size-l.openEnd);while(h<p.childCount){let e=p.child(h),t=d.matchType(e.type);if(!t)break;h++;if(h>1||a==0||e.content.size){d=t;c.push(P(e.mark(f.allowedMarks(e.marks)),h==1?a:0,h==p.childCount?u:-1))}}let m=h==p.childCount;m||(u=-1);this.placed=H(this.placed,n,t.from(c));this.frontier[n].match=d;m&&u<0&&i&&i.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();for(let e=0,t=p;e<u;e++){let e=t.lastChild;this.frontier.push({type:e.type,match:e.contentMatchAt(e.childCount)});t=e.content}this.unplaced=m?e==0?r.empty:new r(G(l.content,e-1,1),e-1,u<0?l.openEnd:e-1):new r(G(l.content,e,h),l.openStart,l.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let e,t=this.frontier[this.depth];if(!t.type.isTextblock||!Q(this.$to,this.$to.depth,t.type,t.match,false)||this.$to.depth==this.depth&&(e=this.findCloseLevel(this.$to))&&e.depth==this.depth)return-1;let{depth:r}=this.$to,n=this.$to.after(r);while(r>1&&n==this.$to.end(--r))++n;return n}findCloseLevel(e){e:for(let t=Math.min(this.depth,e.depth);t>=0;t--){let{match:r,type:n}=this.frontier[t];let i=t<e.depth&&e.end(t+1)==e.pos+(e.depth-(t+1));let s=Q(e,t,n,r,i);if(s){for(let r=t-1;r>=0;r--){let{match:t,type:n}=this.frontier[r];let i=Q(e,r,n,t,true);if(!i||i.childCount)continue e}return{depth:t,fit:s,move:i?e.doc.resolve(e.after(t+1)):e}}}}close(e){let t=this.findCloseLevel(e);if(!t)return null;while(this.depth>t.depth)this.closeFrontierNode();t.fit.childCount&&(this.placed=H(this.placed,t.depth,t.fit));e=t.move;for(let r=t.depth+1;r<=e.depth;r++){let t=e.node(r),n=t.type.contentMatch.fillBefore(t.content,true,e.index(r));this.openFrontierNode(t.type,t.attrs,n)}return e}openFrontierNode(e,r=null,n){let i=this.frontier[this.depth];i.match=i.match.matchType(e);this.placed=H(this.placed,this.depth,t.from(e.create(r,n)));this.frontier.push({type:e,match:e.contentMatch})}closeFrontierNode(){let e=this.frontier.pop();let r=e.match.fillBefore(t.empty,true);r.childCount&&(this.placed=H(this.placed,this.frontier.length,r))}}function G(e,t,r){return t==0?e.cutByIndex(r,e.childCount):e.replaceChild(0,e.firstChild.copy(G(e.firstChild.content,t-1,r)))}function H(e,t,r){return t==0?e.append(r):e.replaceChild(e.childCount-1,e.lastChild.copy(H(e.lastChild.content,t-1,r)))}function K(e,t){for(let r=0;r<t;r++)e=e.firstChild.content;return e}function P(e,r,n){if(r<=0)return e;let i=e.content;r>1&&(i=i.replaceChild(0,P(i.firstChild,r-1,i.childCount==1?n-1:0)));if(r>0){i=e.type.contentMatch.fillBefore(i).append(i);n<=0&&(i=i.append(e.type.contentMatch.matchFragment(i).fillBefore(t.empty,true)))}return e.copy(i)}function Q(e,t,r,n,i){let s=e.node(t),o=i?e.indexAfter(t):e.index(t);if(o==s.childCount&&!r.compatibleContent(s.type))return null;let l=n.fillBefore(s.content,true,o);return l&&!U(r,s.content,o)?l:null}function U(e,t,r){for(let n=r;n<t.childCount;n++)if(!e.allowsMarks(t.child(n).marks))return true;return false}function V(e){return e.spec.defining||e.spec.definingForContent}function X(e,t,n,i){if(!i.size)return e.deleteRange(t,n);let s=e.doc.resolve(t),o=e.doc.resolve(n);if(q(s,o,i))return e.step(new ReplaceStep(t,n,i));let l=te(s,o);l[l.length-1]==0&&l.pop();let p=-(s.depth+1);l.unshift(p);for(let e=s.depth,t=s.pos-1;e>0;e--,t--){let r=s.node(e).type.spec;if(r.defining||r.definingAsContext||r.isolating)break;l.indexOf(e)>-1?p=e:s.before(e)==t&&l.splice(1,0,-e)}let a=l.indexOf(p);let h=[],c=i.openStart;for(let e=i.content,t=0;;t++){let r=e.firstChild;h.push(r);if(t==i.openStart)break;e=r.content}for(let e=c-1;e>=0;e--){let t=h[e],r=V(t.type);if(r&&!t.sameMarkup(s.node(Math.abs(p)-1)))c=e;else if(r||!t.type.isTextblock)break}for(let t=i.openStart;t>=0;t--){let p=(t+c+1)%(i.openStart+1);let d=h[p];if(d)for(let t=0;t<l.length;t++){let h=l[(t+a)%l.length],c=true;if(h<0){c=false;h=-h}let f=s.node(h-1),u=s.index(h-1);if(f.canReplaceWith(u,u,d.type,d.marks))return e.replace(s.before(h),c?o.after(h):n,new r(Y(i.content,0,i.openStart,p),p,i.openEnd))}}let d=e.steps.length;for(let r=l.length-1;r>=0;r--){e.replace(t,n,i);if(e.steps.length>d)break;let p=l[r];if(!(p<0)){t=s.before(p);n=o.after(p)}}}function Y(e,r,n,i,s){if(r<n){let t=e.firstChild;e=e.replaceChild(0,t.copy(Y(t.content,r+1,n,i,t)))}if(r>i){let r=s.contentMatchAt(0);let n=r.fillBefore(e).append(e);e=n.append(r.matchFragment(n).fillBefore(t.empty,true))}return e}function Z(e,n,i,s){if(!s.isInline&&n==i&&e.doc.resolve(n).parent.content.size){let t=W(e.doc,n,s.type);t!=null&&(n=i=t)}e.replaceRange(n,i,new r(t.from(s),0,0))}function ee(e,t,r){let n=e.doc.resolve(t),i=e.doc.resolve(r);let s=te(n,i);for(let t=0;t<s.length;t++){let r=s[t],o=t==s.length-1;if(o&&r==0||n.node(r).type.contentMatch.validEnd)return e.delete(n.start(r),i.end(r));if(r>0&&(o||n.node(r-1).canReplace(n.index(r-1),i.indexAfter(r-1))))return e.delete(n.before(r),i.after(r))}for(let s=1;s<=n.depth&&s<=i.depth;s++)if(t-n.start(s)==n.depth-s&&r>n.end(s)&&i.end(s)-r!=i.depth-s&&n.start(s-1)==i.start(s-1)&&n.node(s-1).canReplace(n.index(s-1),i.index(s-1)))return e.delete(n.before(s),r);e.delete(t,r)}function te(e,t){let r=[],n=Math.min(e.depth,t.depth);for(let i=n;i>=0;i--){let n=e.start(i);if(n<e.pos-(e.depth-i)||t.end(i)>t.pos+(t.depth-i)||e.node(i).type.spec.isolating||t.node(i).type.spec.isolating)break;(n==t.start(i)||i==e.depth&&i==t.depth&&e.parent.inlineContent&&t.parent.inlineContent&&i&&t.start(i-1)==n-1)&&r.push(i)}return r}class AttrStep extends Step{constructor(e,t,r){super();this.pos=e;this.attr=t;this.value=r}apply(e){let n=e.nodeAt(this.pos);if(!n)return StepResult.fail("No node at attribute step's position");let i=Object.create(null);for(let e in n.attrs)i[e]=n.attrs[e];i[this.attr]=this.value;let s=n.type.create(i,null,n.marks);return StepResult.fromReplace(e,this.pos,this.pos+1,new r(t.from(s),0,n.isLeaf?0:1))}getMap(){return StepMap.empty}invert(e){return new AttrStep(this.pos,this.attr,e.nodeAt(this.pos).attrs[this.attr])}map(e){let t=e.mapResult(this.pos,1);return t.deletedAfter?null:new AttrStep(t.pos,this.attr,this.value)}toJSON(){return{stepType:"attr",pos:this.pos,attr:this.attr,value:this.value}}static fromJSON(e,t){if(typeof t.pos!="number"||typeof t.attr!="string")throw new RangeError("Invalid input for AttrStep.fromJSON");return new AttrStep(t.pos,t.attr,t.value)}}Step.jsonID("attr",AttrStep);class DocAttrStep extends Step{constructor(e,t){super();this.attr=e;this.value=t}apply(e){let t=Object.create(null);for(let r in e.attrs)t[r]=e.attrs[r];t[this.attr]=this.value;let r=e.type.create(t,e.content,e.marks);return StepResult.ok(r)}getMap(){return StepMap.empty}invert(e){return new DocAttrStep(this.attr,e.attrs[this.attr])}map(e){return this}toJSON(){return{stepType:"docAttr",attr:this.attr,value:this.value}}static fromJSON(e,t){if(typeof t.attr!="string")throw new RangeError("Invalid input for DocAttrStep.fromJSON");return new DocAttrStep(t.attr,t.value)}}Step.jsonID("docAttr",DocAttrStep);let re=class extends Error{};re=function e(t){let r=Error.call(this,t);r.__proto__=e.prototype;return r};re.prototype=Object.create(Error.prototype);re.prototype.constructor=re;re.prototype.name="TransformError";class Transform{constructor(e){this.doc=e;this.steps=[];this.docs=[];this.mapping=new Mapping}get before(){return this.docs.length?this.docs[0]:this.doc}step(e){let t=this.maybeStep(e);if(t.failed)throw new re(t.failed);return this}maybeStep(e){let t=e.apply(this.doc);t.failed||this.addStep(e,t.doc);return t}get docChanged(){return this.steps.length>0}changedRange(){let e=1e9,t=-1e9;for(let r=0;r<this.mapping.maps.length;r++){let n=this.mapping.maps[r];if(r){e=n.map(e,1);t=n.map(t,-1)}n.forEach(((r,n,i,s)=>{e=Math.min(e,i);t=Math.max(t,s)}))}return e==1e9?null:{from:e,to:t}}addStep(e,t){this.docs.push(this.doc);this.steps.push(e);this.mapping.appendMap(e.getMap());this.doc=t}replace(e,t=e,n=r.empty){let i=L(this.doc,e,t,n);i&&this.step(i);return this}replaceWith(e,n,i){return this.replace(e,n,new r(t.from(i),0,0))}delete(e,t){return this.replace(e,t,r.empty)}insert(e,t){return this.replaceWith(e,e,t)}replaceRange(e,t,r){X(this,e,t,r);return this}replaceRangeWith(e,t,r){Z(this,e,t,r);return this}deleteRange(e,t){ee(this,e,t);return this}lift(e,t){M(this,e,t);return this}join(e,t=1){$(this,e,t);return this}wrap(e,t){C(this,e,t);return this}setBlockType(e,t=e,r,n=null){b(this,e,t,r,n);return this}setNodeMarkup(e,t,r=null,n){E(this,e,t,r,n);return this}setNodeAttribute(e,t,r){this.step(new AttrStep(e,t,r));return this}setDocAttribute(e,t){this.step(new DocAttrStep(e,t));return this}addNodeMark(e,t){this.step(new AddNodeMarkStep(e,t));return this}removeNodeMark(e,t){let r=this.doc.nodeAt(e);if(!r)throw new RangeError("No node at position "+e);if(t instanceof i)t.isInSet(r.marks)&&this.step(new RemoveNodeMarkStep(e,t));else{let n,i=r.marks,s=[];while(n=t.isInSet(i)){s.push(new RemoveNodeMarkStep(e,n));i=n.removeFromSet(i)}for(let e=s.length-1;e>=0;e--)this.step(s[e])}return this}split(e,t=1,r){z(this,e,t,r);return this}addMark(e,t,r){g(this,e,t,r);return this}removeMark(e,t,r){y(this,e,t,r);return this}clearIncompatible(e,t,r){k(this,e,t,r);return this}}export{AddMarkStep,AddNodeMarkStep,AttrStep,DocAttrStep,MapResult,Mapping,RemoveMarkStep,RemoveNodeMarkStep,ReplaceAroundStep,ReplaceStep,Step,StepMap,StepResult,Transform,re as TransformError,F as canJoin,J as canSplit,j as dropPoint,v as findWrapping,W as insertPoint,B as joinPoint,R as liftTarget,L as replaceStep};

